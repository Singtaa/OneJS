// MARK: Interop
if (typeof globalThis.__cs === "undefined") {
    const inv = globalThis.__cs_invoke;
    globalThis.__cs = {
        invoke: inv
    };
}

// MARK: Handle Cleanup
const __handleRegistry = new FinalizationRegistry((handle) => {
    if (handle > 0 && typeof __releaseHandle === "function") {
        __releaseHandle(handle);
    }
});

function releaseObject(obj) {
    if (obj && typeof obj.__csHandle === "number" && obj.__csHandle > 0) {
        __releaseHandle(obj.__csHandle);
        obj.__csHandle = 0;
    }
}

// MARK: Args
function __resolveArgs(args) {
    if (!args || args.length === 0) return args;
    
    const resolved = new Array(args.length);
    for (let i = 0; i < args.length; i++) {
        resolved[i] = __resolveValue(args[i]);
    }
    return resolved;
}

function __resolveValue(value) {
    if (value == null) return value;
    
    if (value.__csPathProxy) {
        return __resolvePathProxy(value);
    }
    
    if (value.__csHandle) {
        return value;
    }
    
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    
    return value;
}

function __resolvePathProxy(value) {
    if (!value || !value.__csPathProxy) return value;

    const path = value.__csPath;
    if (!path || path.length === 0) return value;

    if (path.length >= 2) {
        const parentPath = path.slice(0, -1).join(".");
        const memberName = path[path.length - 1];
        if (__typeExists(parentPath) && __cs.invoke(parentPath, "", 7, 0, 0, [])) {
            return __cs.invoke(parentPath, memberName, 4, 1, 0, []);
        }
    }

    return { __csTypeRef: path.join(".") };
}

// MARK: Generics Support
/**
 * Check if a value represents a C# type reference
 */
function __isTypeRef(value) {
    if (value == null) return false;
    // Type proxy from CS.Some.Type
    if (value.__csPathProxy) return true;
    // Bound generic type
    if (value.__csBoundGeneric) return true;
    // Explicit type reference
    if (value.__csTypeRef) return true;
    return false;
}

/**
 * Extract type name from a type reference
 */
function __getTypeName(typeRef) {
    if (typeRef == null) return null;
    if (typeof typeRef === "string") return typeRef;
    // Check path proxy FIRST - accessing other props on path proxy creates nested proxies
    if (typeRef.__csPathProxy && typeRef.__csPath) return typeRef.__csPath.join(".");
    if (typeRef.__csBoundGeneric) return typeRef.__csBoundTypeName;
    // Only check __csTypeRef for plain objects with explicit type refs
    if (typeRef.__csTypeRef && typeof typeRef.__csTypeRef === "string") return typeRef.__csTypeRef;
    if (typeRef.__csType) return typeRef.__csType;
    return null;
}

/**
 * Create a bound generic type proxy.
 * e.g., List(Int32) returns a proxy for List<Int32>
 */
function __createBoundGenericType(genericDefName, typeArgs) {
    // Build the bound type name: "System.Collections.Generic.List`1" + type args
    const typeArgNames = typeArgs.map(__getTypeName);

    // Append arity suffix if not already present (e.g., List -> List`1)
    let fullGenericDefName = genericDefName;
    if (!genericDefName.includes("`")) {
        fullGenericDefName = genericDefName + "`" + typeArgs.length;
    }

    // Call C# to construct the generic type and get back the full type name
    // CallKind 8 = MakeGenericType
    const boundTypeName = __cs.invoke(fullGenericDefName, "", 8, 0, 0, typeArgNames);

    if (!boundTypeName) {
        throw new Error(`Failed to create generic type: ${genericDefName}<${typeArgNames.join(", ")}>`);
    }

    // Create a proxy for the bound type
    function BoundGenericType(...args) {
        return newObject(boundTypeName, ...args);
    }

    return new Proxy(BoundGenericType, {
        construct(target, args) {
            return newObject(boundTypeName, ...args);
        },
        apply(target, thisArg, args) {
            // Nested generics: Dict(String, List(Int32))
            if (args.length > 0 && args.every(__isTypeRef)) {
                return __createBoundGenericType(boundTypeName, args);
            }
            return newObject(boundTypeName, ...args);
        },
        get(target, prop) {
            if (typeof prop === "symbol") return undefined;
            if (prop === "__csBoundGeneric") return true;
            if (prop === "__csBoundTypeName") return boundTypeName;
            if (prop === "__csType") return boundTypeName;
            if (prop === "__csHandle") return 0;
            if (prop === "toString") {
                return function() { return "[CSGenericType " + boundTypeName + "]"; };
            }
            if (prop === "toJSON") {
                return function() { return { __csTypeRef: boundTypeName }; };
            }

            // Static member access on bound generic type
            const propName = String(prop);
            const firstChar = propName.charAt(0);
            const isLower = firstChar >= "a" && firstChar <= "z";

            if (isLower || __staticPropertyNames.has(propName)) {
                const raw = __cs.invoke(boundTypeName, propName, 2, 1, 0, []);
                return __wrapResultFromCs(null, raw);
            }

            // Static method
            return function(...args) {
                const raw = __cs.invoke(boundTypeName, propName, 1, 1, 0, __resolveArgs(args));
                return __wrapResultFromCs(null, raw);
            };
        },
        set(target, prop, value) {
            if (typeof prop === "symbol") return false;
            __cs.invoke(boundTypeName, String(prop), 3, 1, 0, [__resolveValue(value)]);
            return true;
        }
    });
}

// MARK: Results
function __wrapResultFromCs(typeHint, raw) {
    if (raw == null) return raw;

    if (typeof raw === "object" && raw.__csHandle) {
        const resolvedType = raw.__csType || typeHint || "";
        return __wrapObject(resolvedType, raw.__csHandle);
    }

    // Check for Task marker - C# returns JSON string with __csTaskId
    if (typeof raw === "string" && raw.startsWith("{\"__csTaskId\":")) {
        try {
            const obj = JSON.parse(raw);
            if (obj.__csTaskId !== undefined) {
                // Create and return a Promise that will be resolved when Task completes
                return __createTaskPromise(obj.__csTaskId);
            }
        } catch (e) {
            // Fall through to return raw
        }
    }

    if (typeof raw === "string" && raw.startsWith("{\"__type\":")) {
        try {
            const obj = JSON.parse(raw);
            return obj;
        } catch (e) {
            return raw;
        }
    }

    return raw;
}

// MARK: Objects
function __wrapObject(typeName, handle) {
    if (handle == null || handle === 0) return null;

    const target = {
        __csType: typeName,
        __csHandle: handle
    };

    const proxy = new Proxy(target, {
        get(obj, prop) {
            if (prop === "__csType" || prop === "__csHandle") return obj[prop];
            if (prop === "__csPathProxy") return false;
            if (prop === "__csBoundGeneric") return false;
            if (prop === "__csTypeRef") return undefined;
            if (prop === "__csPath") return undefined;
            if (prop === "__csBoundTypeName") return undefined;

            if (prop === "toString") {
                return function () {
                    return "[CSObject " + (obj.__csType || "?") + "#" + obj.__csHandle + "]";
                };
            }
            
            if (prop === "valueOf") {
                return function () {
                    return obj.__csHandle || 0;
                };
            }

            // Handle toJSON for JSON.stringify compatibility
            // Return a simple object that represents the C# handle
            if (prop === "toJSON") {
                return function () {
                    return { __csHandle: obj.__csHandle, __csType: obj.__csType };
                };
            }

            if (prop === "release" || prop === "dispose") {
                return function() {
                    releaseObject(obj);
                };
            }

            if (typeof prop === "symbol") return undefined;

            const propName = String(prop);
            const typeName = obj.__csType || "";
            const handle = obj.__csHandle || 0;

            // Numeric indexer support: obj[0], obj[1], etc.
            // Routes to get_Item(int) for List<T>, arrays, and other indexed collections
            if (/^\d+$/.test(propName)) {
                const index = parseInt(propName, 10);
                const raw = __cs.invoke(typeName, "get_Item", 1, 0, handle, [index]);
                return __wrapResultFromCs(null, raw);
            }

            const firstChar = propName.charAt(0);
            const isUpper = firstChar >= "A" && firstChar <= "Z";

            // Check if it's a known instance property (like Count, Length)
            if (__instancePropertyNames.has(propName)) {
                const value = __cs.invoke(typeName, propName, 2, 0, handle, []);
                return __wrapResultFromCs(null, value);
            }

            // Indexer methods (get_Item, set_Item) and event methods (add_, remove_) should be treated as methods
            if (propName.startsWith("get_") || propName.startsWith("set_") ||
                propName.startsWith("add_") || propName.startsWith("remove_")) {
                return function (...args) {
                    const raw = __cs.invoke(typeName, propName, 1, 0, handle, __resolveArgs(args));
                    return __wrapResultFromCs(null, raw);
                };
            }

            if (isUpper) {
                return function (...args) {
                    const raw = __cs.invoke(typeName, propName, 1, 0, handle, __resolveArgs(args));
                    return __wrapResultFromCs(null, raw);
                };
            }

            const value = __cs.invoke(typeName, propName, 2, 0, handle, []);
            return __wrapResultFromCs(null, value);
        },
        set(obj, prop, value) {
            if (typeof prop === "symbol") return false;

            const propName = String(prop);
            const resolvedValue = __resolveValue(value);

            // Numeric indexer support: obj[0] = value, obj[1] = value, etc.
            // Routes to set_Item(int, value) for List<T>, arrays, and other indexed collections
            if (/^\d+$/.test(propName)) {
                const index = parseInt(propName, 10);
                __cs.invoke(obj.__csType || "", "set_Item", 1, 0, obj.__csHandle, [index, resolvedValue]);
                return true;
            }

            __cs.invoke(obj.__csType || "", propName, 3, 0, obj.__csHandle, [resolvedValue]);
            return true;
        }
    });
    
    __handleRegistry.register(proxy, handle);
    return proxy;
}

// MARK: Helpers
function newObject(typeName, ...args) {
    const raw = __cs.invoke(typeName, "ctor", 0, 0, 0, __resolveArgs(args));
    return __wrapResultFromCs(typeName, raw);
}

function callMethod(obj, methodName, ...args) {
    if (!obj) throw new Error("callMethod: obj is null");
    const typeName = obj.__csType || "";
    const handle = obj.__csHandle || 0;
    const raw = __cs.invoke(typeName, methodName, 1, 0, handle, __resolveArgs(args));
    return __wrapResultFromCs(null, raw);
}

function callStatic(typeName, methodName, ...args) {
    const raw = __cs.invoke(typeName, methodName, 1, 1, 0, __resolveArgs(args));
    return __wrapResultFromCs(typeName, raw);
}

globalThis.__csHelpers = {
    newObject,
    callMethod,
    callStatic,
    wrapObject: __wrapObject,
    releaseObject
};

// MARK: CS Proxy
const __staticPropertyNames = new Set([
    "time", "deltaTime", "fixedDeltaTime", "unscaledTime", "unscaledDeltaTime",
    "fixedTime", "timeScale", "frameCount", "realtimeSinceStartup",
    "width", "height", "dpi", "fullScreen",
    "platform", "isPlaying", "isEditor", "dataPath", "persistentDataPath",
    "streamingAssetsPath", "temporaryCachePath", "version", "productName",
    "mousePosition", "anyKey", "anyKeyDown",
    "visible", "lockState",
    "gravity"
]);

// Common instance properties that start with uppercase
const __instancePropertyNames = new Set([
    "Count", "Length", "Capacity", "Keys", "Values", "IsReadOnly"
]);

function __typeExists(typeName) {
    if (!typeName) return false;
    const raw = __cs.invoke(typeName, "", 6, 0, 0, []);
    return raw === true || raw === 1;
}

function __createCsPathProxy(path) {
    const typeName = path.join(".");

    function CsType(...args) {
        return newObject(typeName, ...args);
    }

    return new Proxy(CsType, {
        construct(target, args) {
            return newObject(typeName, ...args);
        },
        apply(target, thisArg, args) {
            // Check if this is a generic type binding: List(Int32), Dict(String, Int32)
            // All args must be type references
            if (args.length > 0 && args.every(__isTypeRef)) {
                return __createBoundGenericType(typeName, args);
            }

            // Check if this is a static method call on parent type
            // For paths like AsyncTestHelper.GetValueAsync (length 2) or UnityEngine.Debug.Log (length 3)
            // If the full path is not a type, try calling as static method on parent
            if (path.length >= 2 && !__typeExists(typeName)) {
                const parentPath = path.slice(0, -1).join(".");
                const methodName = path[path.length - 1];
                const raw = __cs.invoke(parentPath, methodName, 1, 1, 0, __resolveArgs(args));
                return __wrapResultFromCs(null, raw);
            }

            // Default: constructor call
            return newObject(typeName, ...args);
        },
        get(target, prop) {
            if (typeof prop === "symbol") return undefined;
        
            if (prop === "__csHandle") return 0;
            if (prop === "__csType") return typeName;
            if (prop === "__csPathProxy") return true;
            if (prop === "__csPath") return path;
        
            if (prop === "toString") {
                return function () { return "[CSType " + typeName + "]"; };
            }
            
            if (prop === "valueOf") {
                return function() {
                    if (path.length >= 3) {
                        const parentPath = path.slice(0, -1).join(".");
                        const memberName = path[path.length - 1];
                        if (__typeExists(parentPath) && __cs.invoke(parentPath, "", 7, 0, 0, [])) {
                            return __cs.invoke(parentPath, memberName, 4, 1, 0, []);
                        }
                    }
                    return 0;
                };
            }

            // Handle toJSON for JSON.stringify compatibility
            if (prop === "toJSON") {
                return function() {
                    return { __csTypeRef: typeName };
                };
            }

            const propName = String(prop);
            const firstChar = propName.charAt(0);
            const isLower = firstChar >= "a" && firstChar <= "z";
        
            if (isLower || __staticPropertyNames.has(propName)) {
                const raw = __cs.invoke(typeName, propName, 2, 1, 0, []);
                return __wrapResultFromCs(null, raw);
            }
        
            const nextPath = path.concat(propName);
            return __createCsPathProxy(nextPath);
        },
        set(target, prop, value) {
            if (typeof prop === "symbol") return false;
            __cs.invoke(typeName, String(prop), 3, 1, 0, [__resolveValue(value)]);
            return true;
        }
    });
}

if (typeof globalThis.CS === "undefined") {
    globalThis.CS = new Proxy({}, {
        get(target, prop) {
            if (typeof prop === "symbol") return undefined;
            if (prop === "toString") {
                return function () { return "[CSRoot]"; };
            }
            return __createCsPathProxy([String(prop)]);
        }
    });
}

// MARK: Events
// Event handler registry - maps elementHandle -> { eventType -> callback }
const __eventHandlers = new Map();

/**
 * Register an event handler for an element.
 * Called by user code or React reconciler.
 * @param {object} element - CS object proxy with __csHandle
 * @param {string} eventType - Event name: click, pointerdown, change, etc.
 * @param {function} callback - Handler function receiving event data
 */
function addEventListener(element, eventType, callback) {
    if (!element || !element.__csHandle) {
        throw new Error("addEventListener: element must be a CS object");
    }
    const handle = element.__csHandle;

    if (!__eventHandlers.has(handle)) {
        __eventHandlers.set(handle, new Map());
    }

    const handlers = __eventHandlers.get(handle);

    // Support multiple handlers per event type
    if (!handlers.has(eventType)) {
        handlers.set(eventType, new Set());
    }
    handlers.get(eventType).add(callback);
}

/**
 * Remove an event handler.
 */
function removeEventListener(element, eventType, callback) {
    if (!element || !element.__csHandle) return;
    const handle = element.__csHandle;

    const handlers = __eventHandlers.get(handle);
    if (!handlers) return;

    const callbacks = handlers.get(eventType);
    if (!callbacks) return;

    callbacks.delete(callback);

    if (callbacks.size === 0) {
        handlers.delete(eventType);
    }
    if (handlers.size === 0) {
        __eventHandlers.delete(handle);
    }
}

/**
 * Remove all event handlers for an element.
 * Call this when element is destroyed/unmounted.
 */
function removeAllEventListeners(element) {
    if (!element || !element.__csHandle) return;
    __eventHandlers.delete(element.__csHandle);
}

/**
 * Called from C# when an event fires.
 * Dispatches to registered JS handlers.
 */
globalThis.__dispatchEvent = function(elementHandle, eventType, eventData) {
    const handlers = __eventHandlers.get(elementHandle);
    if (!handlers) return;

    const callbacks = handlers.get(eventType);
    if (!callbacks || callbacks.size === 0) return;

    // Create synthetic event object
    const event = {
        type: eventType,
        target: elementHandle,
        ...eventData,
        preventDefault() { this.defaultPrevented = true; },
        stopPropagation() { this.propagationStopped = true; },
        defaultPrevented: false,
        propagationStopped: false
    };

    for (const cb of callbacks) {
        try {
            cb(event);
        } catch (e) {
            console.error("Event handler error:", e);
        }
    }
};

// Expose event API
globalThis.__eventAPI = {
    addEventListener,
    removeEventListener,
    removeAllEventListeners
};

// MARK: Scheduling
let __rafId = 0;
const __rafCallbacks = new Map();

let __timerId = 0;
const __timeouts = new Map();
const __intervals = new Map();

// Timestamp from last tick - used as unified time base
let __currentTime = 0;

// Only polyfill performance.now if it doesn't exist (QuickJS)
// In WebGL, the browser already has performance.now() and we shouldn't override it
if (typeof globalThis.performance === "undefined") {
    globalThis.performance = {
        now() { return __currentTime; }
    };
}

// Store original browser APIs before overriding (for WebGL compatibility)
const __nativeSetTimeout = globalThis.setTimeout;
const __nativeClearTimeout = globalThis.clearTimeout;
const __nativeSetInterval = globalThis.setInterval;
const __nativeClearInterval = globalThis.clearInterval;
const __nativeRequestAnimationFrame = globalThis.requestAnimationFrame;
const __nativeCancelAnimationFrame = globalThis.cancelAnimationFrame;

// Custom scheduling driven by Unity's Update loop via __tick
// These replace browser APIs so React uses Unity's frame timing
globalThis.requestAnimationFrame = function(callback) {
    const id = ++__rafId;
    __rafCallbacks.set(id, callback);
    return id;
};

globalThis.cancelAnimationFrame = function(id) {
    __rafCallbacks.delete(id);
};

globalThis.setTimeout = function(callback, delay, ...args) {
    const id = ++__timerId;
    const due = __currentTime + (delay || 0);
    __timeouts.set(id, { callback, due, args });
    return id;
};

globalThis.clearTimeout = function(id) {
    __timeouts.delete(id);
};

globalThis.setInterval = function(callback, interval, ...args) {
    const id = ++__timerId;
    const int = Math.max(interval || 0, 1);
    __intervals.set(id, { callback, interval: int, next: __currentTime + int, args });
    return id;
};

globalThis.clearInterval = function(id) {
    __intervals.delete(id);
};

globalThis.__tick = function(timestamp) {
    __currentTime = timestamp;

    // RAF callbacks
    const rafSnapshot = Array.from(__rafCallbacks.entries());
    __rafCallbacks.clear();

    for (const [id, cb] of rafSnapshot) {
        try {
            cb(timestamp);
        } catch (e) {
            console.error("RAF callback error:", e);
        }
    }

    // Timeouts
    for (const [id, t] of __timeouts) {
        if (timestamp >= t.due) {
            __timeouts.delete(id);
            try {
                t.callback(...t.args);
            } catch (e) {
                console.error("Timeout callback error:", e);
            }
        }
    }

    // Intervals
    for (const [id, t] of __intervals) {
        while (timestamp >= t.next) {
            t.next += t.interval;
            try {
                t.callback(...t.args);
            } catch (e) {
                console.error("Interval callback error:", e);
            }
        }
    }
};

// WebGL: Use browser's native RAF to drive tick instead of Unity's Update
// This avoids PlayerLoop recursion issues when C# Update calls JS which calls back to C#
// Note: We check for native RAF existence rather than UNITY_WEBGL because
// the platform defines aren't set until after bootstrap runs
if (__nativeRequestAnimationFrame) {
    let __webglTickRunning = false;

    function __webglTick(browserTimestamp) {
        if (!__webglTickRunning) return;

        // Update current time using browser's high-precision timestamp
        __currentTime = browserTimestamp;

        // Process RAF callbacks
        const rafSnapshot = Array.from(__rafCallbacks.entries());
        __rafCallbacks.clear();

        for (const [id, cb] of rafSnapshot) {
            try {
                cb(browserTimestamp);
            } catch (e) {
                console.error("RAF callback error:", e);
            }
        }

        // Process timeouts
        for (const [id, t] of __timeouts) {
            if (browserTimestamp >= t.due) {
                __timeouts.delete(id);
                try {
                    t.callback(...t.args);
                } catch (e) {
                    console.error("Timeout callback error:", e);
                }
            }
        }

        // Process intervals
        for (const [id, t] of __intervals) {
            while (browserTimestamp >= t.next) {
                t.next += t.interval;
                try {
                    t.callback(...t.args);
                } catch (e) {
                    console.error("Interval callback error:", e);
                }
            }
        }

        // Schedule next tick
        __nativeRequestAnimationFrame(__webglTick);
    }

    // Start the WebGL tick loop (called from C# in WebGL builds)
    globalThis.__startWebGLTick = function() {
        if (__webglTickRunning) return;
        __webglTickRunning = true;
        __nativeRequestAnimationFrame(__webglTick);
    };

    globalThis.__stopWebGLTick = function() {
        __webglTickRunning = false;
    };
}

// MARK: Tasks (C# async/await support)
// Maps taskId -> { resolve, reject } for pending C# Tasks
const __pendingTaskPromises = new Map();

/**
 * Create a Promise for a C# Task.
 * Called from __wrapResultFromCs when receiving InteropType.TaskHandle.
 */
function __createTaskPromise(taskId) {
    return new Promise((resolve, reject) => {
        __pendingTaskPromises.set(taskId, { resolve, reject });
    });
}

/**
 * Called from C# when a Task completes successfully.
 * Resolves the corresponding JS Promise.
 */
globalThis.__resolveTask = function(taskId, result) {
    const pending = __pendingTaskPromises.get(taskId);
    if (!pending) {
        console.warn("__resolveTask: No pending promise for taskId", taskId);
        return;
    }
    __pendingTaskPromises.delete(taskId);

    // Wrap result if it's a C# object handle
    const wrapped = __wrapResultFromCs(null, result);
    pending.resolve(wrapped);
};

/**
 * Called from C# when a Task fails or is canceled.
 * Rejects the corresponding JS Promise.
 */
globalThis.__rejectTask = function(taskId, errorMessage) {
    const pending = __pendingTaskPromises.get(taskId);
    if (!pending) {
        console.warn("__rejectTask: No pending promise for taskId", taskId);
        return;
    }
    __pendingTaskPromises.delete(taskId);
    pending.reject(new Error(errorMessage));
};

// MARK: Microtasks
// Simple microtask queue for Promise-like behavior
const __microtaskQueue = [];
let __microtaskScheduled = false;

globalThis.queueMicrotask = function(callback) {
    __microtaskQueue.push(callback);
    
    if (!__microtaskScheduled) {
        __microtaskScheduled = true;
        // QuickJS has native Promise, use it to flush microtasks
        Promise.resolve().then(__flushMicrotasks);
    }
};

function __flushMicrotasks() {
    __microtaskScheduled = false;
    const tasks = __microtaskQueue.splice(0);
    for (const task of tasks) {
        try {
            task();
        } catch (e) {
            console.error("Microtask error:", e);
        }
    }
}

// MARK: setImmediate
// setImmediate - executes callback via microtask queue (synchronously in same tick)
// This is needed by React's scheduler as a priority over setTimeout
const __immediateCallbacks = new Map();
let __immediateId = 0;

globalThis.setImmediate = function(callback, ...args) {
    const id = ++__immediateId;
    __immediateCallbacks.set(id, { callback, args });

    // Schedule via microtask to run "immediately" but after current execution
    queueMicrotask(() => {
        const item = __immediateCallbacks.get(id);
        if (item) {
            __immediateCallbacks.delete(id);
            try {
                item.callback(...item.args);
            } catch (e) {
                console.error("setImmediate callback error:", e);
            }
        }
    });

    return id;
};

globalThis.clearImmediate = function(id) {
    __immediateCallbacks.delete(id);
};

// MARK: StyleSheet API
/**
 * Load a USS file from the working directory and apply it to the root element.
 * @param {string} path - Path relative to working directory (e.g., "styles/main.uss")
 * @returns {boolean} True if successful
 */
globalThis.loadStyleSheet = function(path) {
    if (!globalThis.__bridge) {
        console.error("loadStyleSheet: __bridge not available");
        return false;
    }
    return globalThis.__bridge.LoadStyleSheet(path);
};

/**
 * Compile a USS string and apply it to the root element.
 * @param {string} ussContent - USS content string
 * @param {string} [name] - Optional name for debugging
 * @returns {boolean} True if successful
 */
globalThis.compileStyleSheet = function(ussContent, name) {
    if (!globalThis.__bridge) {
        console.error("compileStyleSheet: __bridge not available");
        return false;
    }
    return globalThis.__bridge.CompileStyleSheet(ussContent, name || "inline");
};