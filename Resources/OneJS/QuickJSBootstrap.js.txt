// MARK: Interop
if (typeof globalThis.__cs === "undefined") {
    const inv = globalThis.__cs_invoke;
    globalThis.__cs = {
        invoke: inv
    };
}

// MARK: Handle Cleanup
// FinalizationRegistry to automatically release C# object handles when JS wrappers are GC'd
const __handleRegistry = new FinalizationRegistry((handle) => {
    if (handle > 0 && typeof __releaseHandle === "function") {
        __releaseHandle(handle);
    }
});

// Manual release function for explicit cleanup
function releaseObject(obj) {
    if (obj && typeof obj.__csHandle === "number" && obj.__csHandle > 0) {
        __releaseHandle(obj.__csHandle);
        obj.__csHandle = 0;
    }
}

// MARK: Struct Deserialization
// Unity structs (Vector3, Color, etc.) are serialized as JSON by C#
// We deserialize them back to plain objects with helper methods

function __deserializeStruct(jsonStr) {
    if (typeof jsonStr !== "string" || !jsonStr.startsWith("{")) {
        return null;
    }
    
    try {
        const obj = JSON.parse(jsonStr);
        if (!obj || !obj.__struct) return null;
        
        // Add helper methods based on struct type
        switch (obj.__struct) {
            case "Vector2":
            case "Vector3":
            case "Vector4":
            case "Vector2Int":
            case "Vector3Int":
                // Add magnitude, normalized, etc. helpers
                Object.defineProperty(obj, "magnitude", {
                    get() {
                        let sum = 0;
                        if ("x" in this) sum += this.x * this.x;
                        if ("y" in this) sum += this.y * this.y;
                        if ("z" in this) sum += this.z * this.z;
                        if ("w" in this) sum += this.w * this.w;
                        return Math.sqrt(sum);
                    }
                });
                break;
        }
        
        return obj;
    } catch (e) {
        return null;
    }
}

// Check if a value looks like a struct that should be converted to Vector3, Color, etc.
function __isPlainVectorLike(value) {
    return typeof value === "object" && value !== null && 
           !value.__csHandle && !value.__struct &&
           ("x" in value || "r" in value);
}

// Convert a plain object to the appropriate Unity struct type for property setting
function __convertToUnityStruct(value, propertyName) {
    if (!__isPlainVectorLike(value)) return value;
    
    // Infer type from property name or value shape
    const lowerProp = propertyName.toLowerCase();
    
    // Color properties
    if (lowerProp.includes("color") || "r" in value && "g" in value && "b" in value) {
        if ("a" in value) {
            return new CS.UnityEngine.Color(value.r, value.g, value.b, value.a);
        }
        return new CS.UnityEngine.Color(value.r, value.g, value.b, 1);
    }
    
    // Quaternion properties
    if (lowerProp.includes("rotation") && "w" in value) {
        return new CS.UnityEngine.Quaternion(value.x, value.y, value.z, value.w);
    }
    
    // Vector4
    if ("w" in value && "x" in value) {
        return new CS.UnityEngine.Vector4(value.x, value.y, value.z || 0, value.w);
    }
    
    // Vector3 (most common case for position, scale, etc.)
    if ("z" in value) {
        return new CS.UnityEngine.Vector3(value.x, value.y, value.z);
    }
    
    // Vector2
    if ("x" in value && "y" in value) {
        return new CS.UnityEngine.Vector2(value.x, value.y);
    }
    
    return value;
}

// MARK: Utils
function __wrapResultFromCs(typeHint, raw) {
    if (raw == null) return raw;

    // Object handles come back as { __csHandle: number, __csType?: string }
    if (typeof raw === "object" && raw.__csHandle) {
        // Prefer __csType from raw object (set by C# typeHint), fallback to typeHint parameter
        const resolvedType = raw.__csType || typeHint || "";
        return __wrapObject(resolvedType, raw.__csHandle);
    }

    // Unity structs (Vector3, Color, etc.) are serialized as JSON strings by C#
    // Check if this is a serialized struct and deserialize it
    if (typeof raw === "string" && raw.startsWith("{\"__struct\":")) {
        const deserialized = __deserializeStruct(raw);
        if (deserialized) return deserialized;
    }

    return raw;
}

// MARK: Objects
function __wrapObject(typeName, handle) {
    if (handle == null || handle === 0) return null;

    const target = {
        __csType: typeName,
        __csHandle: handle
    };

    const proxy = new Proxy(target, {
        get(obj, prop) {
            if (prop === "__csType" || prop === "__csHandle") return obj[prop];

            if (prop === "toString") {
                return function () {
                    return "[CSObject " + (obj.__csType || "?") + "#" + obj.__csHandle + "]";
                };
            }
            
            // Allow explicit release
            if (prop === "release" || prop === "dispose") {
                return function() {
                    releaseObject(obj);
                };
            }

            if (typeof prop === "symbol") {
                // Ignore Symbol.toPrimitive etc
                return undefined;
            }

            const propName = String(prop);
            const typeName = obj.__csType || "";
            const handle = obj.__csHandle || 0;

            // Heuristic:
            // - lowerCamelCase => treat as property (transform, position, tag, name, etc.)
            // - PascalCase     => treat as method (SetActive, AddComponent, etc.)
            const firstChar = propName.charAt(0);
            const isUpper = firstChar >= "A" && firstChar <= "Z";

            if (isUpper) {
                // Method call: go.SetActive(false)
                return function (...args) {
                    const raw = __cs.invoke(typeName, propName, 1 /* Method */, 0 /* instance */, handle, args);
                    return __wrapResultFromCs(null, raw);
                };
            }

            // Property get: go.transform, go.transform.position, etc.
            const value = __cs.invoke(typeName, propName, 2 /* GetProp */, 0 /* instance */, handle, []);
            return __wrapResultFromCs(null, value);
        },
        set(obj, prop, value) {
            if (typeof prop === "symbol") {
                return false;
            }
            
            const propName = String(prop);
            
            // IMPORTANT: Struct copy semantics warning
            // In C#, structs like Vector3 have copy semantics. This means:
            //   go.transform.position.x = 10  // Does NOTHING - modifies a copy
            // You must set the entire struct:
            //   go.transform.position = { x: 10, y: 0, z: 0 }
            //   go.transform.position = new CS.UnityEngine.Vector3(10, 0, 0)
            
            // If value is a plain object with vector-like properties (x/y/z or r/g/b),
            // convert it to the appropriate Unity struct type
            let convertedValue = value;
            if (__isPlainVectorLike(value)) {
                convertedValue = __convertToUnityStruct(value, propName);
            }
            
            __cs.invoke(obj.__csType || "", propName, 3 /* SetProp */, 0 /* instance */, obj.__csHandle, [convertedValue]);
            return true;
        }
    });
    
    // Register for automatic cleanup when proxy is garbage collected
    __handleRegistry.register(proxy, handle);
    
    return proxy;
}


// MARK: Helpers
function newObject(typeName, ...args) {
    const raw = __cs.invoke(typeName, "ctor", 0, 0, 0, args);
    return __wrapResultFromCs(typeName, raw);
}

function callMethod(obj, methodName, ...args) {
    if (!obj) throw new Error("callMethod: obj is null");
    const typeName = obj.__csType || "";
    const handle = obj.__csHandle || 0;
    const raw = __cs.invoke(typeName, methodName, 1, 0, handle, args);
    return __wrapResultFromCs(null, raw);
}

function callStatic(typeName, methodName, ...args) {
    const raw = __cs.invoke(typeName, methodName, 1, 1, 0, args);
    return __wrapResultFromCs(typeName, raw);
}

globalThis.__csHelpers = {
    newObject,
    callMethod,
    callStatic,
    wrapObject: __wrapObject,
    releaseObject,
    deserializeStruct: __deserializeStruct,
    isPlainVectorLike: __isPlainVectorLike,
    convertToUnityStruct: __convertToUnityStruct
};

// MARK: CS
// Static property names - these are accessed as properties, not methods
const __staticPropertyNames = new Set([
    // Time
    "time", "deltaTime", "fixedDeltaTime", "unscaledTime", "unscaledDeltaTime",
    "fixedTime", "timeScale", "frameCount", "realtimeSinceStartup",
    // Screen
    "width", "height", "dpi", "fullScreen",
    // Application
    "platform", "isPlaying", "isEditor", "dataPath", "persistentDataPath",
    "streamingAssetsPath", "temporaryCachePath", "version", "productName",
    // Input (legacy)
    "mousePosition", "anyKey", "anyKeyDown",
    // Cursor
    "visible", "lockState",
    // Physics
    "gravity"
]);

// Check if a type name resolves to an actual C# type
function __typeExists(typeName) {
    if (!typeName) return false;
    const raw = __cs.invoke(typeName, "", 6 /* TypeExists */, 0, 0, []);
    return raw === true || raw === 1;
}

function __createCsPathProxy(path) {
    const typeName = path.join(".");

    function CsType(...args) {
        return newObject(typeName, ...args);
    }

    return new Proxy(CsType, {
        construct(target, args) {
            // Always treat construct as type instantiation
            return newObject(typeName, ...args);
        },
        apply(target, thisArg, args) {
            // For paths with 3+ segments, could be:
            // - Constructor: CS.UnityEngine.UIElements.VisualElement()
            // - Static method: CS.UnityEngine.Debug.Log()
            
            if (path.length >= 3) {
                // Check if full path is actually a type
                if (!__typeExists(typeName)) {
                    // Not a type - treat last segment as method on parent type
                    const parentPath = path.slice(0, -1).join(".");
                    const methodName = path[path.length - 1];
                    const raw = __cs.invoke(parentPath, methodName, 1 /* Method */, 1 /* static */, 0, args);
                    return __wrapResultFromCs(null, raw);
                }
            }
            
            // It's a type (or short path) - instantiate
            return newObject(typeName, ...args);
        },
        get(target, prop) {
            if (typeof prop === "symbol") {
                return undefined;
            }

            if (prop === "toString") {
                return function () {
                    return "[CSType " + typeName + "]";
                };
            }

            const propName = String(prop);
            const firstChar = propName.charAt(0);
            const isLower = firstChar >= "a" && firstChar <= "z";

            // Lowercase OR known static property => immediate property getter
            if (isLower || __staticPropertyNames.has(propName)) {
                const raw = __cs.invoke(typeName, propName, 2 /* GetProp */, 1 /* static */, 0, []);
                return __wrapResultFromCs(null, raw);
            }

            // PascalCase => could be nested namespace, nested type, or method
            // Always return new proxy to defer resolution until invocation
            const nextPath = path.concat(propName);
            return __createCsPathProxy(nextPath);
        },
        set(target, prop, value) {
            if (typeof prop === "symbol") {
                return false;
            }
            
            // Static property setter
            __cs.invoke(typeName, String(prop), 3 /* SetProp */, 1 /* static */, 0, [value]);
            return true;
        }
    });
}

if (typeof globalThis.CS === "undefined") {
    globalThis.CS = new Proxy({}, {
        get(target, prop) {
            if (typeof prop === "symbol") {
                return undefined;
            }
            if (prop === "toString") {
                return function () {
                    return "[CSRoot]";
                };
            }
            // First segment: "UnityEngine", "System", etc.
            return __createCsPathProxy([String(prop)]);
        }
    });
}