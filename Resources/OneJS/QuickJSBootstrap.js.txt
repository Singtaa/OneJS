// MARK: Interop
if (typeof globalThis.__cs === "undefined") {
    const inv = globalThis.__cs_invoke;
    globalThis.__cs = {
        invoke: inv
    };
}

// MARK: Handle Cleanup
const __handleRegistry = new FinalizationRegistry((handle) => {
    if (handle > 0 && typeof __releaseHandle === "function") {
        __releaseHandle(handle);
    }
});

function releaseObject(obj) {
    if (obj && typeof obj.__csHandle === "number" && obj.__csHandle > 0) {
        __releaseHandle(obj.__csHandle);
        obj.__csHandle = 0;
    }
}

// MARK: Args
// Resolve arguments before passing to C# - handles path proxies (enums) and plain objects
function __resolveArgs(args) {
    if (!args || args.length === 0) return args;
    
    const resolved = new Array(args.length);
    for (let i = 0; i < args.length; i++) {
        resolved[i] = __resolveValue(args[i]);
    }
    return resolved;
}

// Resolve a single value - handles path proxies, CS objects, and plain objects
function __resolveValue(value) {
    if (value == null) return value;
    
    // Path proxy (enum value) - resolve to int
    if (value.__csPathProxy) {
        return __resolvePathProxy(value);
    }
    
    // CS object - already has handle
    if (value.__csHandle) {
        return value;
    }
    
    // Plain object - could be struct data like {x: 1, y: 2, z: 3}
    // C# will handle type-aware conversion based on target property/parameter type
    if (typeof value === "object" && !Array.isArray(value)) {
        // Pass as-is - C# knows the target type and will convert
        return value;
    }
    
    return value;
}

// Resolve path proxies (e.g., enum values or type references) to their actual values
function __resolvePathProxy(value) {
    if (!value || !value.__csPathProxy) return value;
    
    const path = value.__csPath;
    if (!path || path.length === 0) return value;
    
    // Check if it's an enum value (parent type exists and is enum)
    if (path.length >= 2) {
        const parentPath = path.slice(0, -1).join(".");
        const memberName = path[path.length - 1];
        if (__typeExists(parentPath) && __cs.invoke(parentPath, "", 7 /* IsEnumType */, 0, 0, [])) {
            return __cs.invoke(parentPath, memberName, 4 /* GetField */, 1 /* static */, 0, []);
        }
    }
    
    // Not an enum - return type reference marker (C# converts to System.Type)
    return { __csTypeRef: path.join(".") };
}

// MARK: Results
// Process return values from C#
function __wrapResultFromCs(typeHint, raw) {
    if (raw == null) return raw;

    // Object handle - wrap in proxy
    if (typeof raw === "object" && raw.__csHandle) {
        const resolvedType = raw.__csType || typeHint || "";
        return __wrapObject(resolvedType, raw.__csHandle);
    }

    // Struct data from C# comes as JSON with __type field
    // Parse it to plain object for easy JS usage
    if (typeof raw === "string" && raw.startsWith("{\"__type\":")) {
        try {
            const obj = JSON.parse(raw);
            // Remove __type - it's internal metadata
            // User can still check obj constructor or add type guards
            return obj;
        } catch (e) {
            return raw;
        }
    }

    return raw;
}

// MARK: Objects
function __wrapObject(typeName, handle) {
    if (handle == null || handle === 0) return null;

    const target = {
        __csType: typeName,
        __csHandle: handle
    };

    const proxy = new Proxy(target, {
        get(obj, prop) {
            if (prop === "__csType" || prop === "__csHandle") return obj[prop];
            if (prop === "__csPathProxy") return false;

            if (prop === "toString") {
                return function () {
                    return "[CSObject " + (obj.__csType || "?") + "#" + obj.__csHandle + "]";
                };
            }
            
            if (prop === "valueOf") {
                return function () {
                    return obj.__csHandle || 0;
                };
            }
            
            if (prop === "release" || prop === "dispose") {
                return function() {
                    releaseObject(obj);
                };
            }

            if (typeof prop === "symbol") return undefined;

            const propName = String(prop);
            const typeName = obj.__csType || "";
            const handle = obj.__csHandle || 0;

            // Heuristic: lowerCamelCase => property, PascalCase => method
            const firstChar = propName.charAt(0);
            const isUpper = firstChar >= "A" && firstChar <= "Z";

            if (isUpper) {
                // Method
                return function (...args) {
                    const raw = __cs.invoke(typeName, propName, 1, 0, handle, __resolveArgs(args));
                    return __wrapResultFromCs(null, raw);
                };
            }

            // Property get
            const value = __cs.invoke(typeName, propName, 2, 0, handle, []);
            return __wrapResultFromCs(null, value);
        },
        set(obj, prop, value) {
            if (typeof prop === "symbol") return false;
            
            const propName = String(prop);
            
            // Resolve the value (handles enums, etc.)
            // Plain objects like {x:1, y:2, z:3} pass through - C# knows target type
            const resolvedValue = __resolveValue(value);
            
            __cs.invoke(obj.__csType || "", propName, 3, 0, obj.__csHandle, [resolvedValue]);
            return true;
        }
    });
    
    __handleRegistry.register(proxy, handle);
    return proxy;
}

// MARK: Helpers
function newObject(typeName, ...args) {
    const raw = __cs.invoke(typeName, "ctor", 0, 0, 0, __resolveArgs(args));
    return __wrapResultFromCs(typeName, raw);
}

function callMethod(obj, methodName, ...args) {
    if (!obj) throw new Error("callMethod: obj is null");
    const typeName = obj.__csType || "";
    const handle = obj.__csHandle || 0;
    const raw = __cs.invoke(typeName, methodName, 1, 0, handle, __resolveArgs(args));
    return __wrapResultFromCs(null, raw);
}

function callStatic(typeName, methodName, ...args) {
    const raw = __cs.invoke(typeName, methodName, 1, 1, 0, __resolveArgs(args));
    return __wrapResultFromCs(typeName, raw);
}

globalThis.__csHelpers = {
    newObject,
    callMethod,
    callStatic,
    wrapObject: __wrapObject,
    releaseObject
};

// MARK: CS Proxy
const __staticPropertyNames = new Set([
    "time", "deltaTime", "fixedDeltaTime", "unscaledTime", "unscaledDeltaTime",
    "fixedTime", "timeScale", "frameCount", "realtimeSinceStartup",
    "width", "height", "dpi", "fullScreen",
    "platform", "isPlaying", "isEditor", "dataPath", "persistentDataPath",
    "streamingAssetsPath", "temporaryCachePath", "version", "productName",
    "mousePosition", "anyKey", "anyKeyDown",
    "visible", "lockState",
    "gravity"
]);

function __typeExists(typeName) {
    if (!typeName) return false;
    const raw = __cs.invoke(typeName, "", 6, 0, 0, []);
    return raw === true || raw === 1;
}

function __createCsPathProxy(path) {
    const typeName = path.join(".");

    function CsType(...args) {
        return newObject(typeName, ...args);
    }

    return new Proxy(CsType, {
        construct(target, args) {
            return newObject(typeName, ...args);
        },
        apply(target, thisArg, args) {
            if (path.length >= 3) {
                if (!__typeExists(typeName)) {
                    const parentPath = path.slice(0, -1).join(".");
                    const methodName = path[path.length - 1];
                    const raw = __cs.invoke(parentPath, methodName, 1, 1, 0, __resolveArgs(args));
                    return __wrapResultFromCs(null, raw);
                }
            }
            return newObject(typeName, ...args);
        },
        get(target, prop) {
            if (typeof prop === "symbol") return undefined;
        
            if (prop === "__csHandle") return 0;
            if (prop === "__csType") return typeName;
            if (prop === "__csPathProxy") return true;
            if (prop === "__csPath") return path;
        
            if (prop === "toString") {
                return function () { return "[CSType " + typeName + "]"; };
            }
            
            if (prop === "valueOf") {
                return function() {
                    if (path.length >= 3) {
                        const parentPath = path.slice(0, -1).join(".");
                        const memberName = path[path.length - 1];
                        if (__typeExists(parentPath) && __cs.invoke(parentPath, "", 7, 0, 0, [])) {
                            return __cs.invoke(parentPath, memberName, 4, 1, 0, []);
                        }
                    }
                    return 0;
                };
            }
        
            const propName = String(prop);
            const firstChar = propName.charAt(0);
            const isLower = firstChar >= "a" && firstChar <= "z";
        
            if (isLower || __staticPropertyNames.has(propName)) {
                const raw = __cs.invoke(typeName, propName, 2, 1, 0, []);
                return __wrapResultFromCs(null, raw);
            }
        
            const nextPath = path.concat(propName);
            return __createCsPathProxy(nextPath);
        },
        set(target, prop, value) {
            if (typeof prop === "symbol") return false;
            __cs.invoke(typeName, String(prop), 3, 1, 0, [__resolveValue(value)]);
            return true;
        }
    });
}

if (typeof globalThis.CS === "undefined") {
    globalThis.CS = new Proxy({}, {
        get(target, prop) {
            if (typeof prop === "symbol") return undefined;
            if (prop === "toString") {
                return function () { return "[CSRoot]"; };
            }
            return __createCsPathProxy([String(prop)]);
        }
    });
}