// MARK: Interop
if (typeof globalThis.__cs === "undefined") {
    const inv = globalThis.__cs_invoke;
    globalThis.__cs = {
        invoke: inv
    };
}

// MARK: Handle Cleanup
const __handleRegistry = new FinalizationRegistry((handle) => {
    if (handle > 0 && typeof __releaseHandle === "function") {
        __releaseHandle(handle);
    }
});

function releaseObject(obj) {
    if (obj && typeof obj.__csHandle === "number" && obj.__csHandle > 0) {
        __releaseHandle(obj.__csHandle);
        obj.__csHandle = 0;
    }
}

// MARK: Args
function __resolveArgs(args) {
    if (!args || args.length === 0) return args;
    
    const resolved = new Array(args.length);
    for (let i = 0; i < args.length; i++) {
        resolved[i] = __resolveValue(args[i]);
    }
    return resolved;
}

function __resolveValue(value) {
    if (value == null) return value;
    
    if (value.__csPathProxy) {
        return __resolvePathProxy(value);
    }
    
    if (value.__csHandle) {
        return value;
    }
    
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    
    return value;
}

function __resolvePathProxy(value) {
    if (!value || !value.__csPathProxy) return value;
    
    const path = value.__csPath;
    if (!path || path.length === 0) return value;
    
    if (path.length >= 2) {
        const parentPath = path.slice(0, -1).join(".");
        const memberName = path[path.length - 1];
        if (__typeExists(parentPath) && __cs.invoke(parentPath, "", 7, 0, 0, [])) {
            return __cs.invoke(parentPath, memberName, 4, 1, 0, []);
        }
    }
    
    return { __csTypeRef: path.join(".") };
}

// MARK: Results
function __wrapResultFromCs(typeHint, raw) {
    if (raw == null) return raw;

    if (typeof raw === "object" && raw.__csHandle) {
        const resolvedType = raw.__csType || typeHint || "";
        return __wrapObject(resolvedType, raw.__csHandle);
    }

    if (typeof raw === "string" && raw.startsWith("{\"__type\":")) {
        try {
            const obj = JSON.parse(raw);
            return obj;
        } catch (e) {
            return raw;
        }
    }

    return raw;
}

// MARK: Objects
function __wrapObject(typeName, handle) {
    if (handle == null || handle === 0) return null;

    const target = {
        __csType: typeName,
        __csHandle: handle
    };

    const proxy = new Proxy(target, {
        get(obj, prop) {
            if (prop === "__csType" || prop === "__csHandle") return obj[prop];
            if (prop === "__csPathProxy") return false;

            if (prop === "toString") {
                return function () {
                    return "[CSObject " + (obj.__csType || "?") + "#" + obj.__csHandle + "]";
                };
            }
            
            if (prop === "valueOf") {
                return function () {
                    return obj.__csHandle || 0;
                };
            }

            // Handle toJSON for JSON.stringify compatibility
            // Return a simple object that represents the C# handle
            if (prop === "toJSON") {
                return function () {
                    return { __csHandle: obj.__csHandle, __csType: obj.__csType };
                };
            }

            if (prop === "release" || prop === "dispose") {
                return function() {
                    releaseObject(obj);
                };
            }

            if (typeof prop === "symbol") return undefined;

            const propName = String(prop);
            const typeName = obj.__csType || "";
            const handle = obj.__csHandle || 0;

            const firstChar = propName.charAt(0);
            const isUpper = firstChar >= "A" && firstChar <= "Z";

            if (isUpper) {
                return function (...args) {
                    const raw = __cs.invoke(typeName, propName, 1, 0, handle, __resolveArgs(args));
                    return __wrapResultFromCs(null, raw);
                };
            }

            const value = __cs.invoke(typeName, propName, 2, 0, handle, []);
            return __wrapResultFromCs(null, value);
        },
        set(obj, prop, value) {
            if (typeof prop === "symbol") return false;
            
            const propName = String(prop);
            const resolvedValue = __resolveValue(value);
            
            __cs.invoke(obj.__csType || "", propName, 3, 0, obj.__csHandle, [resolvedValue]);
            return true;
        }
    });
    
    __handleRegistry.register(proxy, handle);
    return proxy;
}

// MARK: Helpers
function newObject(typeName, ...args) {
    const raw = __cs.invoke(typeName, "ctor", 0, 0, 0, __resolveArgs(args));
    return __wrapResultFromCs(typeName, raw);
}

function callMethod(obj, methodName, ...args) {
    if (!obj) throw new Error("callMethod: obj is null");
    const typeName = obj.__csType || "";
    const handle = obj.__csHandle || 0;
    const raw = __cs.invoke(typeName, methodName, 1, 0, handle, __resolveArgs(args));
    return __wrapResultFromCs(null, raw);
}

function callStatic(typeName, methodName, ...args) {
    const raw = __cs.invoke(typeName, methodName, 1, 1, 0, __resolveArgs(args));
    return __wrapResultFromCs(typeName, raw);
}

globalThis.__csHelpers = {
    newObject,
    callMethod,
    callStatic,
    wrapObject: __wrapObject,
    releaseObject
};

// MARK: CS Proxy
const __staticPropertyNames = new Set([
    "time", "deltaTime", "fixedDeltaTime", "unscaledTime", "unscaledDeltaTime",
    "fixedTime", "timeScale", "frameCount", "realtimeSinceStartup",
    "width", "height", "dpi", "fullScreen",
    "platform", "isPlaying", "isEditor", "dataPath", "persistentDataPath",
    "streamingAssetsPath", "temporaryCachePath", "version", "productName",
    "mousePosition", "anyKey", "anyKeyDown",
    "visible", "lockState",
    "gravity"
]);

function __typeExists(typeName) {
    if (!typeName) return false;
    const raw = __cs.invoke(typeName, "", 6, 0, 0, []);
    return raw === true || raw === 1;
}

function __createCsPathProxy(path) {
    const typeName = path.join(".");

    function CsType(...args) {
        return newObject(typeName, ...args);
    }

    return new Proxy(CsType, {
        construct(target, args) {
            return newObject(typeName, ...args);
        },
        apply(target, thisArg, args) {
            if (path.length >= 3) {
                if (!__typeExists(typeName)) {
                    const parentPath = path.slice(0, -1).join(".");
                    const methodName = path[path.length - 1];
                    const raw = __cs.invoke(parentPath, methodName, 1, 1, 0, __resolveArgs(args));
                    return __wrapResultFromCs(null, raw);
                }
            }
            return newObject(typeName, ...args);
        },
        get(target, prop) {
            if (typeof prop === "symbol") return undefined;
        
            if (prop === "__csHandle") return 0;
            if (prop === "__csType") return typeName;
            if (prop === "__csPathProxy") return true;
            if (prop === "__csPath") return path;
        
            if (prop === "toString") {
                return function () { return "[CSType " + typeName + "]"; };
            }
            
            if (prop === "valueOf") {
                return function() {
                    if (path.length >= 3) {
                        const parentPath = path.slice(0, -1).join(".");
                        const memberName = path[path.length - 1];
                        if (__typeExists(parentPath) && __cs.invoke(parentPath, "", 7, 0, 0, [])) {
                            return __cs.invoke(parentPath, memberName, 4, 1, 0, []);
                        }
                    }
                    return 0;
                };
            }

            // Handle toJSON for JSON.stringify compatibility
            if (prop === "toJSON") {
                return function() {
                    return { __csTypeRef: typeName };
                };
            }

            const propName = String(prop);
            const firstChar = propName.charAt(0);
            const isLower = firstChar >= "a" && firstChar <= "z";
        
            if (isLower || __staticPropertyNames.has(propName)) {
                const raw = __cs.invoke(typeName, propName, 2, 1, 0, []);
                return __wrapResultFromCs(null, raw);
            }
        
            const nextPath = path.concat(propName);
            return __createCsPathProxy(nextPath);
        },
        set(target, prop, value) {
            if (typeof prop === "symbol") return false;
            __cs.invoke(typeName, String(prop), 3, 1, 0, [__resolveValue(value)]);
            return true;
        }
    });
}

if (typeof globalThis.CS === "undefined") {
    globalThis.CS = new Proxy({}, {
        get(target, prop) {
            if (typeof prop === "symbol") return undefined;
            if (prop === "toString") {
                return function () { return "[CSRoot]"; };
            }
            return __createCsPathProxy([String(prop)]);
        }
    });
}

// MARK: Events
// Event handler registry - maps elementHandle -> { eventType -> callback }
const __eventHandlers = new Map();

/**
 * Register an event handler for an element.
 * Called by user code or React reconciler.
 * @param {object} element - CS object proxy with __csHandle
 * @param {string} eventType - Event name: click, pointerdown, change, etc.
 * @param {function} callback - Handler function receiving event data
 */
function addEventListener(element, eventType, callback) {
    if (!element || !element.__csHandle) {
        throw new Error("addEventListener: element must be a CS object");
    }
    const handle = element.__csHandle;

    if (!__eventHandlers.has(handle)) {
        __eventHandlers.set(handle, new Map());
    }

    const handlers = __eventHandlers.get(handle);

    // Support multiple handlers per event type
    if (!handlers.has(eventType)) {
        handlers.set(eventType, new Set());
    }
    handlers.get(eventType).add(callback);
}

/**
 * Remove an event handler.
 */
function removeEventListener(element, eventType, callback) {
    if (!element || !element.__csHandle) return;
    const handle = element.__csHandle;

    const handlers = __eventHandlers.get(handle);
    if (!handlers) return;

    const callbacks = handlers.get(eventType);
    if (!callbacks) return;

    callbacks.delete(callback);

    if (callbacks.size === 0) {
        handlers.delete(eventType);
    }
    if (handlers.size === 0) {
        __eventHandlers.delete(handle);
    }
}

/**
 * Remove all event handlers for an element.
 * Call this when element is destroyed/unmounted.
 */
function removeAllEventListeners(element) {
    if (!element || !element.__csHandle) return;
    __eventHandlers.delete(element.__csHandle);
}

/**
 * Called from C# when an event fires.
 * Dispatches to registered JS handlers.
 */
globalThis.__dispatchEvent = function(elementHandle, eventType, eventData) {
    const handlers = __eventHandlers.get(elementHandle);
    if (!handlers) return;

    const callbacks = handlers.get(eventType);
    if (!callbacks || callbacks.size === 0) return;

    // Create synthetic event object
    const event = {
        type: eventType,
        target: elementHandle,
        ...eventData,
        preventDefault() { this.defaultPrevented = true; },
        stopPropagation() { this.propagationStopped = true; },
        defaultPrevented: false,
        propagationStopped: false
    };

    for (const cb of callbacks) {
        try {
            cb(event);
        } catch (e) {
            console.error("Event handler error:", e);
        }
    }
};

// Expose event API
globalThis.__eventAPI = {
    addEventListener,
    removeEventListener,
    removeAllEventListeners
};

// MARK: Scheduling
let __rafId = 0;
const __rafCallbacks = new Map();

let __timerId = 0;
const __timeouts = new Map();
const __intervals = new Map();

// Timestamp from last tick - used as unified time base
let __currentTime = 0;

globalThis.performance = {
    now() { return __currentTime; }
};

globalThis.requestAnimationFrame = function(callback) {
    const id = ++__rafId;
    __rafCallbacks.set(id, callback);
    return id;
};

globalThis.cancelAnimationFrame = function(id) {
    __rafCallbacks.delete(id);
};

globalThis.setTimeout = function(callback, delay, ...args) {
    const id = ++__timerId;
    const due = __currentTime + (delay || 0);
    __timeouts.set(id, { callback, due, args });
    return id;
};

globalThis.clearTimeout = function(id) {
    __timeouts.delete(id);
};

globalThis.setInterval = function(callback, interval, ...args) {
    const id = ++__timerId;
    const int = Math.max(interval || 0, 1);
    __intervals.set(id, { callback, interval: int, next: __currentTime + int, args });
    return id;
};

globalThis.clearInterval = function(id) {
    __intervals.delete(id);
};

globalThis.__tick = function(timestamp) {
    __currentTime = timestamp;
    
    // RAF callbacks
    const rafSnapshot = Array.from(__rafCallbacks.entries());
    __rafCallbacks.clear();
    
    for (const [id, cb] of rafSnapshot) {
        try {
            cb(timestamp);
        } catch (e) {
            console.error("RAF callback error:", e);
        }
    }
    
    // Timeouts
    for (const [id, t] of __timeouts) {
        if (timestamp >= t.due) {
            __timeouts.delete(id);
            try {
                t.callback(...t.args);
            } catch (e) {
                console.error("Timeout callback error:", e);
            }
        }
    }
    
    // Intervals
    for (const [id, t] of __intervals) {
        while (timestamp >= t.next) {
            t.next += t.interval;
            try {
                t.callback(...t.args);
            } catch (e) {
                console.error("Interval callback error:", e);
            }
        }
    }
};

// MARK: Microtasks
// Simple microtask queue for Promise-like behavior
const __microtaskQueue = [];
let __microtaskScheduled = false;

globalThis.queueMicrotask = function(callback) {
    __microtaskQueue.push(callback);
    
    if (!__microtaskScheduled) {
        __microtaskScheduled = true;
        // QuickJS has native Promise, use it to flush microtasks
        Promise.resolve().then(__flushMicrotasks);
    }
};

function __flushMicrotasks() {
    __microtaskScheduled = false;
    const tasks = __microtaskQueue.splice(0);
    for (const task of tasks) {
        try {
            task();
        } catch (e) {
            console.error("Microtask error:", e);
        }
    }
}

// MARK: setImmediate
// setImmediate - executes callback via microtask queue (synchronously in same tick)
// This is needed by React's scheduler as a priority over setTimeout
const __immediateCallbacks = new Map();
let __immediateId = 0;

globalThis.setImmediate = function(callback, ...args) {
    const id = ++__immediateId;
    __immediateCallbacks.set(id, { callback, args });

    // Schedule via microtask to run "immediately" but after current execution
    queueMicrotask(() => {
        const item = __immediateCallbacks.get(id);
        if (item) {
            __immediateCallbacks.delete(id);
            try {
                item.callback(...item.args);
            } catch (e) {
                console.error("setImmediate callback error:", e);
            }
        }
    });

    return id;
};

globalThis.clearImmediate = function(id) {
    __immediateCallbacks.delete(id);
};