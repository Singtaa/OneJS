// MARK: Interop
if (typeof globalThis.__cs === "undefined") {
    const inv = globalThis.__cs_invoke;
    globalThis.__cs = {
        invoke: inv
    };
}

// MARK: Handle Cleanup
// Track released handles to prevent double-free from FinalizationRegistry
const __releasedHandles = new Set();

// Forward declaration - actual Map created in Events section
// This allows __cleanupHandle to reference it before initialization
let __eventHandlers = new Map();

const __handleRegistry = new FinalizationRegistry((handle) => {
    // Skip if already released manually or handle is invalid
    if (handle <= 0 || __releasedHandles.has(handle)) {
        __releasedHandles.delete(handle); // Clean up the tracking set
        return;
    }
    if (typeof __releaseHandle === "function") {
        __cleanupHandle(handle);
        __releaseHandle(handle);
    }
});

/**
 * Clean up all JS-side resources associated with a handle.
 * Called before releasing the handle to C#.
 */
function __cleanupHandle(handle) {
    // Clean up event handlers for this element
    __eventHandlers.delete(handle);
}

/**
 * Manually release a C# object. Safe to call multiple times.
 */
function releaseObject(obj) {
    if (obj && typeof obj.__csHandle === "number" && obj.__csHandle > 0) {
        const handle = obj.__csHandle;
        if (!__releasedHandles.has(handle)) {
            __releasedHandles.add(handle);
            __cleanupHandle(handle);
            __releaseHandle(handle);
        }
        obj.__csHandle = 0;
    }
}

// MARK: Args
function __resolveArgs(args) {
    if (!args || args.length === 0) return args;
    
    const resolved = new Array(args.length);
    for (let i = 0; i < args.length; i++) {
        resolved[i] = __resolveValue(args[i]);
    }
    return resolved;
}

function __resolveValue(value) {
    if (value == null) return value;
    
    if (value.__csPathProxy) {
        return __resolvePathProxy(value);
    }
    
    if (value.__csHandle) {
        return value;
    }
    
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    
    return value;
}

function __resolvePathProxy(value) {
    if (!value || !value.__csPathProxy) return value;

    const path = value.__csPath;
    if (!path || path.length === 0) return value;

    if (path.length >= 2) {
        const parentPath = path.slice(0, -1).join(".");
        const memberName = path[path.length - 1];
        if (__typeExists(parentPath) && __cs.invoke(parentPath, "", 7, 0, 0, [])) {
            return __cs.invoke(parentPath, memberName, 4, 1, 0, []);
        }
    }

    return { __csTypeRef: path.join(".") };
}

// MARK: Generics Support
/**
 * Check if a value represents a C# type reference
 */
function __isTypeRef(value) {
    if (value == null) return false;
    // Type proxy from CS.Some.Type
    if (value.__csPathProxy) return true;
    // Bound generic type
    if (value.__csBoundGeneric) return true;
    // Explicit type reference
    if (value.__csTypeRef) return true;
    return false;
}

/**
 * Extract type name from a type reference
 */
function __getTypeName(typeRef) {
    if (typeRef == null) return null;
    if (typeof typeRef === "string") return typeRef;
    // Check path proxy FIRST - accessing other props on path proxy creates nested proxies
    if (typeRef.__csPathProxy && typeRef.__csPath) return typeRef.__csPath.join(".");
    if (typeRef.__csBoundGeneric) return typeRef.__csBoundTypeName;
    // Only check __csTypeRef for plain objects with explicit type refs
    if (typeRef.__csTypeRef && typeof typeRef.__csTypeRef === "string") return typeRef.__csTypeRef;
    if (typeRef.__csType) return typeRef.__csType;
    return null;
}

/**
 * Create a bound generic type proxy.
 * e.g., List(Int32) returns a proxy for List<Int32>
 */
function __createBoundGenericType(genericDefName, typeArgs) {
    // Build the bound type name: "System.Collections.Generic.List`1" + type args
    const typeArgNames = typeArgs.map(__getTypeName);

    // Append arity suffix if not already present (e.g., List -> List`1)
    let fullGenericDefName = genericDefName;
    if (!genericDefName.includes("`")) {
        fullGenericDefName = genericDefName + "`" + typeArgs.length;
    }

    // Call C# to construct the generic type and get back the full type name
    // CallKind 8 = MakeGenericType
    const boundTypeName = __cs.invoke(fullGenericDefName, "", 8, 0, 0, typeArgNames);

    if (!boundTypeName) {
        throw new Error(`Failed to create generic type: ${genericDefName}<${typeArgNames.join(", ")}>`);
    }

    // Create a proxy for the bound type
    function BoundGenericType(...args) {
        return newObject(boundTypeName, ...args);
    }

    return new Proxy(BoundGenericType, {
        construct(target, args) {
            return newObject(boundTypeName, ...args);
        },
        apply(target, thisArg, args) {
            // Nested generics: Dict(String, List(Int32))
            if (args.length > 0 && args.every(__isTypeRef)) {
                return __createBoundGenericType(boundTypeName, args);
            }
            return newObject(boundTypeName, ...args);
        },
        get(target, prop) {
            if (typeof prop === "symbol") return undefined;
            if (prop === "__csBoundGeneric") return true;
            if (prop === "__csBoundTypeName") return boundTypeName;
            if (prop === "__csType") return boundTypeName;
            if (prop === "__csHandle") return 0;
            if (prop === "toString") {
                return function() { return "[CSGenericType " + boundTypeName + "]"; };
            }
            if (prop === "toJSON") {
                return function() { return { __csTypeRef: boundTypeName }; };
            }

            // Static member access on bound generic type
            const propName = String(prop);
            const firstChar = propName.charAt(0);
            const isLower = firstChar >= "a" && firstChar <= "z";

            if (isLower || __staticPropertyNames.has(propName)) {
                const raw = __cs.invoke(boundTypeName, propName, 2, 1, 0, []);
                return __wrapResultFromCs(null, raw);
            }

            // Static method
            return function(...args) {
                const raw = __cs.invoke(boundTypeName, propName, 1, 1, 0, __resolveArgs(args));
                return __wrapResultFromCs(null, raw);
            };
        },
        set(target, prop, value) {
            if (typeof prop === "symbol") return false;
            __cs.invoke(boundTypeName, String(prop), 3, 1, 0, [__resolveValue(value)]);
            return true;
        }
    });
}

// MARK: Results
function __wrapResultFromCs(typeHint, raw) {
    if (raw == null) return raw;

    if (typeof raw === "object" && raw.__csHandle) {
        const resolvedType = raw.__csType || typeHint || "";
        return __wrapObject(resolvedType, raw.__csHandle);
    }

    // Check for Task marker - C# returns JSON string with __csTaskId
    if (typeof raw === "string" && raw.startsWith("{\"__csTaskId\":")) {
        try {
            const obj = JSON.parse(raw);
            if (obj.__csTaskId !== undefined) {
                // Create and return a Promise that will be resolved when Task completes
                return __createTaskPromise(obj.__csTaskId);
            }
        } catch (e) {
            // Fall through to return raw
        }
    }

    if (typeof raw === "string" && raw.startsWith("{\"__type\":")) {
        try {
            const obj = JSON.parse(raw);
            return obj;
        } catch (e) {
            return raw;
        }
    }

    return raw;
}

// MARK: Objects
function __wrapObject(typeName, handle) {
    if (handle == null || handle === 0) return null;

    const target = {
        __csType: typeName,
        __csHandle: handle
    };

    const proxy = new Proxy(target, {
        get(obj, prop) {
            if (prop === "__csType" || prop === "__csHandle") return obj[prop];
            if (prop === "__csPathProxy") return false;
            if (prop === "__csBoundGeneric") return false;
            if (prop === "__csTypeRef") return undefined;
            if (prop === "__csPath") return undefined;
            if (prop === "__csBoundTypeName") return undefined;

            if (prop === "toString") {
                return function () {
                    return "[CSObject " + (obj.__csType || "?") + "#" + obj.__csHandle + "]";
                };
            }
            
            if (prop === "valueOf") {
                return function () {
                    return obj.__csHandle || 0;
                };
            }

            // Handle toJSON for JSON.stringify compatibility
            // Return a simple object that represents the C# handle
            if (prop === "toJSON") {
                return function () {
                    return { __csHandle: obj.__csHandle, __csType: obj.__csType };
                };
            }

            if (prop === "release" || prop === "dispose") {
                return function() {
                    releaseObject(obj);
                };
            }

            if (typeof prop === "symbol") return undefined;

            const propName = String(prop);
            const typeName = obj.__csType || "";
            const handle = obj.__csHandle || 0;

            // Numeric indexer support: obj[0], obj[1], etc.
            // Routes to get_Item(int) for List<T>, arrays, and other indexed collections
            if (/^\d+$/.test(propName)) {
                const index = parseInt(propName, 10);
                const raw = __cs.invoke(typeName, "get_Item", 1, 0, handle, [index]);
                return __wrapResultFromCs(null, raw);
            }

            const firstChar = propName.charAt(0);
            const isUpper = firstChar >= "A" && firstChar <= "Z";

            // Check if it's a known instance property (like Count, Length)
            if (__instancePropertyNames.has(propName)) {
                const value = __cs.invoke(typeName, propName, 2, 0, handle, []);
                return __wrapResultFromCs(null, value);
            }

            // Indexer methods (get_Item, set_Item) and event methods (add_, remove_) should be treated as methods
            if (propName.startsWith("get_") || propName.startsWith("set_") ||
                propName.startsWith("add_") || propName.startsWith("remove_")) {
                return function (...args) {
                    const raw = __cs.invoke(typeName, propName, 1, 0, handle, __resolveArgs(args));
                    return __wrapResultFromCs(null, raw);
                };
            }

            if (isUpper) {
                return function (...args) {
                    const raw = __cs.invoke(typeName, propName, 1, 0, handle, __resolveArgs(args));
                    return __wrapResultFromCs(null, raw);
                };
            }

            const value = __cs.invoke(typeName, propName, 2, 0, handle, []);
            return __wrapResultFromCs(null, value);
        },
        set(obj, prop, value) {
            if (typeof prop === "symbol") return false;

            const propName = String(prop);
            const resolvedValue = __resolveValue(value);

            // Numeric indexer support: obj[0] = value, obj[1] = value, etc.
            // Routes to set_Item(int, value) for List<T>, arrays, and other indexed collections
            if (/^\d+$/.test(propName)) {
                const index = parseInt(propName, 10);
                __cs.invoke(obj.__csType || "", "set_Item", 1, 0, obj.__csHandle, [index, resolvedValue]);
                return true;
            }

            __cs.invoke(obj.__csType || "", propName, 3, 0, obj.__csHandle, [resolvedValue]);
            return true;
        }
    });
    
    __handleRegistry.register(proxy, handle);
    return proxy;
}

// MARK: Helpers
function newObject(typeName, ...args) {
    const raw = __cs.invoke(typeName, "ctor", 0, 0, 0, __resolveArgs(args));
    return __wrapResultFromCs(typeName, raw);
}

function callMethod(obj, methodName, ...args) {
    if (!obj) throw new Error("callMethod: obj is null");
    const typeName = obj.__csType || "";
    const handle = obj.__csHandle || 0;
    const raw = __cs.invoke(typeName, methodName, 1, 0, handle, __resolveArgs(args));
    return __wrapResultFromCs(null, raw);
}

function callStatic(typeName, methodName, ...args) {
    const raw = __cs.invoke(typeName, methodName, 1, 1, 0, __resolveArgs(args));
    return __wrapResultFromCs(typeName, raw);
}

globalThis.__csHelpers = {
    newObject,
    callMethod,
    callStatic,
    wrapObject: __wrapObject,
    releaseObject
};

// MARK: CS Proxy
const __staticPropertyNames = new Set([
    "time", "deltaTime", "fixedDeltaTime", "unscaledTime", "unscaledDeltaTime",
    "fixedTime", "timeScale", "frameCount", "realtimeSinceStartup",
    "width", "height", "dpi", "fullScreen",
    "platform", "isPlaying", "isEditor", "dataPath", "persistentDataPath",
    "streamingAssetsPath", "temporaryCachePath", "version", "productName",
    "mousePosition", "anyKey", "anyKeyDown",
    "visible", "lockState",
    "gravity"
]);

// Common instance properties that start with uppercase
const __instancePropertyNames = new Set([
    "Count", "Length", "Capacity", "Keys", "Values", "IsReadOnly"
]);

function __typeExists(typeName) {
    if (!typeName) return false;
    const raw = __cs.invoke(typeName, "", 6, 0, 0, []);
    return raw === true || raw === 1;
}

function __createCsPathProxy(path) {
    const typeName = path.join(".");

    function CsType(...args) {
        return newObject(typeName, ...args);
    }

    return new Proxy(CsType, {
        construct(target, args) {
            return newObject(typeName, ...args);
        },
        apply(target, thisArg, args) {
            // Check if this is a generic type binding: List(Int32), Dict(String, Int32)
            // All args must be type references
            if (args.length > 0 && args.every(__isTypeRef)) {
                return __createBoundGenericType(typeName, args);
            }

            // Check if this is a static method call on parent type
            // For paths like AsyncTestHelper.GetValueAsync (length 2) or UnityEngine.Debug.Log (length 3)
            // If the full path is not a type, try calling as static method on parent
            if (path.length >= 2 && !__typeExists(typeName)) {
                const parentPath = path.slice(0, -1).join(".");
                const methodName = path[path.length - 1];
                const raw = __cs.invoke(parentPath, methodName, 1, 1, 0, __resolveArgs(args));
                return __wrapResultFromCs(null, raw);
            }

            // Default: constructor call
            return newObject(typeName, ...args);
        },
        get(target, prop) {
            if (typeof prop === "symbol") return undefined;
        
            if (prop === "__csHandle") return 0;
            if (prop === "__csType") return typeName;
            if (prop === "__csPathProxy") return true;
            if (prop === "__csPath") return path;
        
            if (prop === "toString") {
                return function () { return "[CSType " + typeName + "]"; };
            }
            
            if (prop === "valueOf") {
                return function() {
                    if (path.length >= 3) {
                        const parentPath = path.slice(0, -1).join(".");
                        const memberName = path[path.length - 1];
                        if (__typeExists(parentPath) && __cs.invoke(parentPath, "", 7, 0, 0, [])) {
                            return __cs.invoke(parentPath, memberName, 4, 1, 0, []);
                        }
                    }
                    return 0;
                };
            }

            // Handle toJSON for JSON.stringify compatibility
            if (prop === "toJSON") {
                return function() {
                    return { __csTypeRef: typeName };
                };
            }

            const propName = String(prop);
            const firstChar = propName.charAt(0);
            const isLower = firstChar >= "a" && firstChar <= "z";
        
            if (isLower || __staticPropertyNames.has(propName)) {
                const raw = __cs.invoke(typeName, propName, 2, 1, 0, []);
                return __wrapResultFromCs(null, raw);
            }
        
            const nextPath = path.concat(propName);
            return __createCsPathProxy(nextPath);
        },
        set(target, prop, value) {
            if (typeof prop === "symbol") return false;
            __cs.invoke(typeName, String(prop), 3, 1, 0, [__resolveValue(value)]);
            return true;
        }
    });
}

if (typeof globalThis.CS === "undefined") {
    globalThis.CS = new Proxy({}, {
        get(target, prop) {
            if (typeof prop === "symbol") return undefined;
            if (prop === "toString") {
                return function () { return "[CSRoot]"; };
            }
            return __createCsPathProxy([String(prop)]);
        }
    });
}

// MARK: Events
// Event handler registry - maps elementHandle -> { eventType -> Set<callback> }
// Note: __eventHandlers is declared at top of file for use by __cleanupHandle

/**
 * Register an event handler for an element.
 * Called by user code or React reconciler.
 * @param {object} element - CS object proxy with __csHandle
 * @param {string} eventType - Event name: click, pointerdown, change, etc.
 * @param {function} callback - Handler function receiving event data
 */
function addEventListener(element, eventType, callback) {
    if (!element || !element.__csHandle) {
        throw new Error("addEventListener: element must be a CS object");
    }
    const handle = element.__csHandle;

    if (!__eventHandlers.has(handle)) {
        __eventHandlers.set(handle, new Map());
    }

    const handlers = __eventHandlers.get(handle);

    // Support multiple handlers per event type
    if (!handlers.has(eventType)) {
        handlers.set(eventType, new Set());
    }
    handlers.get(eventType).add(callback);
}

/**
 * Remove an event handler.
 */
function removeEventListener(element, eventType, callback) {
    if (!element || !element.__csHandle) return;
    const handle = element.__csHandle;

    const handlers = __eventHandlers.get(handle);
    if (!handlers) return;

    const callbacks = handlers.get(eventType);
    if (!callbacks) return;

    callbacks.delete(callback);

    if (callbacks.size === 0) {
        handlers.delete(eventType);
    }
    if (handlers.size === 0) {
        __eventHandlers.delete(handle);
    }
}

/**
 * Remove all event handlers for an element.
 * Call this when element is destroyed/unmounted.
 */
function removeAllEventListeners(element) {
    if (!element || !element.__csHandle) return;
    __eventHandlers.delete(element.__csHandle);
}

/**
 * Called from C# when an event fires.
 * Dispatches to registered JS handlers.
 */
globalThis.__dispatchEvent = function(elementHandle, eventType, eventData) {
    const handlers = __eventHandlers.get(elementHandle);
    if (!handlers) return;

    const callbacks = handlers.get(eventType);
    if (!callbacks || callbacks.size === 0) return;

    // Create synthetic event object
    const event = {
        type: eventType,
        target: elementHandle,
        ...eventData,
        preventDefault() { this.defaultPrevented = true; },
        stopPropagation() { this.propagationStopped = true; },
        defaultPrevented: false,
        propagationStopped: false
    };

    for (const cb of callbacks) {
        try {
            cb(event);
        } catch (e) {
            console.error("Event handler error:", e);
        }
    }
};

// Expose event API
globalThis.__eventAPI = {
    addEventListener,
    removeEventListener,
    removeAllEventListeners
};

// MARK: Scheduling
let __rafId = 0;
const __rafCallbacks = new Map();

let __timerId = 0;
const __timeouts = new Map();
const __intervals = new Map();

// Timestamp from last tick - used as unified time base
let __currentTime = 0;

// Only polyfill performance.now if it doesn't exist (QuickJS)
// In WebGL, the browser already has performance.now() and we shouldn't override it
if (typeof globalThis.performance === "undefined") {
    globalThis.performance = {
        now() { return __currentTime; }
    };
}

// Store original browser APIs before overriding (for WebGL compatibility)
const __nativeSetTimeout = globalThis.setTimeout;
const __nativeClearTimeout = globalThis.clearTimeout;
const __nativeSetInterval = globalThis.setInterval;
const __nativeClearInterval = globalThis.clearInterval;
const __nativeRequestAnimationFrame = globalThis.requestAnimationFrame;
const __nativeCancelAnimationFrame = globalThis.cancelAnimationFrame;

// Custom scheduling driven by Unity's Update loop via __tick
// These replace browser APIs so React uses Unity's frame timing
globalThis.requestAnimationFrame = function(callback) {
    const id = ++__rafId;
    __rafCallbacks.set(id, callback);
    return id;
};

globalThis.cancelAnimationFrame = function(id) {
    __rafCallbacks.delete(id);
};

globalThis.setTimeout = function(callback, delay, ...args) {
    const id = ++__timerId;
    const due = __currentTime + (delay || 0);
    __timeouts.set(id, { callback, due, args });
    return id;
};

globalThis.clearTimeout = function(id) {
    __timeouts.delete(id);
};

globalThis.setInterval = function(callback, interval, ...args) {
    const id = ++__timerId;
    const int = Math.max(interval || 0, 1);
    __intervals.set(id, { callback, interval: int, next: __currentTime + int, args });
    return id;
};

globalThis.clearInterval = function(id) {
    __intervals.delete(id);
};

globalThis.__tick = function(timestamp) {
    __currentTime = timestamp;

    // RAF callbacks
    const rafSnapshot = Array.from(__rafCallbacks.entries());
    __rafCallbacks.clear();

    for (const [id, cb] of rafSnapshot) {
        try {
            cb(timestamp);
        } catch (e) {
            console.error("RAF callback error:", e);
        }
    }

    // Timeouts
    for (const [id, t] of __timeouts) {
        if (timestamp >= t.due) {
            __timeouts.delete(id);
            try {
                t.callback(...t.args);
            } catch (e) {
                console.error("Timeout callback error:", e);
            }
        }
    }

    // Intervals
    for (const [id, t] of __intervals) {
        while (timestamp >= t.next) {
            t.next += t.interval;
            try {
                t.callback(...t.args);
            } catch (e) {
                console.error("Interval callback error:", e);
            }
        }
    }
};

// WebGL: Use browser's native RAF to drive tick instead of Unity's Update
// This avoids PlayerLoop recursion issues when C# Update calls JS which calls back to C#
// Note: We check for native RAF existence rather than UNITY_WEBGL because
// the platform defines aren't set until after bootstrap runs
if (__nativeRequestAnimationFrame) {
    let __webglTickRunning = false;

    function __webglTick(browserTimestamp) {
        if (!__webglTickRunning) return;

        // Update current time using browser's high-precision timestamp
        __currentTime = browserTimestamp;

        // Process RAF callbacks
        const rafSnapshot = Array.from(__rafCallbacks.entries());
        __rafCallbacks.clear();

        for (const [id, cb] of rafSnapshot) {
            try {
                cb(browserTimestamp);
            } catch (e) {
                console.error("RAF callback error:", e);
            }
        }

        // Process timeouts
        for (const [id, t] of __timeouts) {
            if (browserTimestamp >= t.due) {
                __timeouts.delete(id);
                try {
                    t.callback(...t.args);
                } catch (e) {
                    console.error("Timeout callback error:", e);
                }
            }
        }

        // Process intervals
        for (const [id, t] of __intervals) {
            while (browserTimestamp >= t.next) {
                t.next += t.interval;
                try {
                    t.callback(...t.args);
                } catch (e) {
                    console.error("Interval callback error:", e);
                }
            }
        }

        // Schedule next tick
        __nativeRequestAnimationFrame(__webglTick);
    }

    // Start the WebGL tick loop (called from C# in WebGL builds)
    globalThis.__startWebGLTick = function() {
        if (__webglTickRunning) return;
        __webglTickRunning = true;
        __nativeRequestAnimationFrame(__webglTick);
    };

    globalThis.__stopWebGLTick = function() {
        __webglTickRunning = false;
    };
}

// MARK: Tasks (C# async/await support)
// Maps taskId -> { resolve, reject } for pending C# Tasks
const __pendingTaskPromises = new Map();

/**
 * Create a Promise for a C# Task.
 * Called from __wrapResultFromCs when receiving InteropType.TaskHandle.
 */
function __createTaskPromise(taskId) {
    return new Promise((resolve, reject) => {
        __pendingTaskPromises.set(taskId, { resolve, reject });
    });
}

/**
 * Called from C# when a Task completes successfully.
 * Resolves the corresponding JS Promise.
 */
globalThis.__resolveTask = function(taskId, result) {
    const pending = __pendingTaskPromises.get(taskId);
    if (!pending) {
        // No pending promise - task was registered from C# without JS involvement.
        // This is valid for C#-only async operations and monitoring tests.
        return;
    }
    __pendingTaskPromises.delete(taskId);

    // Wrap result if it's a C# object handle
    const wrapped = __wrapResultFromCs(null, result);
    pending.resolve(wrapped);
};

/**
 * Called from C# when a Task fails or is canceled.
 * Rejects the corresponding JS Promise.
 */
globalThis.__rejectTask = function(taskId, errorMessage) {
    const pending = __pendingTaskPromises.get(taskId);
    if (!pending) {
        // No pending promise - task was registered from C# without JS involvement.
        return;
    }
    __pendingTaskPromises.delete(taskId);
    pending.reject(new Error(errorMessage));
};

// MARK: Microtasks
// Simple microtask queue for Promise-like behavior
const __microtaskQueue = [];
let __microtaskScheduled = false;

globalThis.queueMicrotask = function(callback) {
    __microtaskQueue.push(callback);
    
    if (!__microtaskScheduled) {
        __microtaskScheduled = true;
        // QuickJS has native Promise, use it to flush microtasks
        Promise.resolve().then(__flushMicrotasks);
    }
};

function __flushMicrotasks() {
    __microtaskScheduled = false;
    const tasks = __microtaskQueue.splice(0);
    for (const task of tasks) {
        try {
            task();
        } catch (e) {
            console.error("Microtask error:", e);
        }
    }
}

// MARK: setImmediate
// setImmediate - executes callback via microtask queue (synchronously in same tick)
// This is needed by React's scheduler as a priority over setTimeout
const __immediateCallbacks = new Map();
let __immediateId = 0;

globalThis.setImmediate = function(callback, ...args) {
    const id = ++__immediateId;
    __immediateCallbacks.set(id, { callback, args });

    // Schedule via microtask to run "immediately" but after current execution
    queueMicrotask(() => {
        const item = __immediateCallbacks.get(id);
        if (item) {
            __immediateCallbacks.delete(id);
            try {
                item.callback(...item.args);
            } catch (e) {
                console.error("setImmediate callback error:", e);
            }
        }
    });

    return id;
};

globalThis.clearImmediate = function(id) {
    __immediateCallbacks.delete(id);
};

// MARK: StyleSheet API
/**
 * Load a USS file from the working directory and apply it to the root element.
 * @param {string} path - Path relative to working directory (e.g., "styles/main.uss")
 * @returns {boolean} True if successful
 */
globalThis.loadStyleSheet = function(path) {
    if (!globalThis.__bridge) {
        console.error("loadStyleSheet: __bridge not available");
        return false;
    }
    return globalThis.__bridge.LoadStyleSheet(path);
};

/**
 * Compile a USS string and apply it to the root element.
 * @param {string} ussContent - USS content string
 * @param {string} [name] - Optional name for debugging
 * @returns {boolean} True if successful
 */
globalThis.compileStyleSheet = function(ussContent, name) {
    if (!globalThis.__bridge) {
        console.error("compileStyleSheet: __bridge not available");
        return false;
    }
    return globalThis.__bridge.CompileStyleSheet(ussContent, name || "inline");
};

// MARK: Fetch API
/**
 * Fetch API implementation using Unity's UnityWebRequest.
 * Matches the web fetch() API signature and returns a Promise.
 *
 * @param {string} url - The URL to fetch
 * @param {Object} [options] - Request options
 * @param {string} [options.method="GET"] - HTTP method
 * @param {Object} [options.headers] - Request headers
 * @param {string|Object} [options.body] - Request body (auto-stringified if object)
 * @returns {Promise<Response>} Promise resolving to a Response object
 *
 * @example
 * // Simple GET
 * const response = await fetch("https://api.example.com/data");
 * const data = await response.json();
 *
 * @example
 * // POST with JSON
 * const response = await fetch("https://api.example.com/data", {
 *     method: "POST",
 *     headers: { "Content-Type": "application/json" },
 *     body: JSON.stringify({ name: "test" })
 * });
 */
globalThis.fetch = function(url, options) {
    options = options || {};
    var method = options.method || "GET";
    var headers = options.headers || null;
    var body = options.body || null;

    // Auto-stringify body if it's an object
    if (body && typeof body === "object") {
        body = JSON.stringify(body);
        // Set Content-Type if not already set
        if (!headers) headers = {};
        if (!headers["Content-Type"]) {
            headers["Content-Type"] = "application/json";
        }
    }

    var headersJson = headers ? JSON.stringify(headers) : null;

    // Call C# FetchAsync and wrap result in Response object
    return CS.OneJS.Network.FetchAsync(url, method, body, headersJson)
        .then(function(result) {
            return new Response(result);
        });
};

/**
 * Response class matching the web Response API.
 * Wraps the C# FetchResponse object.
 */
class Response {
    constructor(fetchResult) {
        // Parse JSON if it's a string (from C# FetchAsync)
        if (typeof fetchResult === "string") {
            fetchResult = JSON.parse(fetchResult);
        }
        this._body = fetchResult.body || "";
        this._headers = new Headers(fetchResult.headers);
        this.ok = fetchResult.ok;
        this.status = fetchResult.status;
        this.statusText = fetchResult.statusText || "";
        this.url = fetchResult.url || "";
        this._bodyUsed = false;
    }

    get bodyUsed() {
        return this._bodyUsed;
    }

    get headers() {
        return this._headers;
    }

    /**
     * Returns the body as text.
     * @returns {Promise<string>}
     */
    text() {
        if (this._bodyUsed) {
            return Promise.reject(new TypeError("Body has already been consumed"));
        }
        this._bodyUsed = true;
        return Promise.resolve(this._body);
    }

    /**
     * Parses the body as JSON.
     * @returns {Promise<any>}
     */
    json() {
        return this.text().then(function(text) {
            return JSON.parse(text);
        });
    }

    /**
     * Returns a clone of the response.
     * @returns {Response}
     */
    clone() {
        if (this._bodyUsed) {
            throw new TypeError("Cannot clone a Response whose body has been consumed");
        }
        var cloned = new Response({
            body: this._body,
            headers: this._headers._headers,
            ok: this.ok,
            status: this.status,
            statusText: this.statusText,
            url: this.url
        });
        return cloned;
    }
}

/**
 * Headers class matching the web Headers API.
 */
class Headers {
    constructor(init) {
        this._headers = {};
        if (init) {
            // Handle both plain objects and Headers instances
            var source = init._headers || init;
            for (var key in source) {
                if (source.hasOwnProperty(key)) {
                    this._headers[key.toLowerCase()] = source[key];
                }
            }
        }
    }

    get(name) {
        return this._headers[name.toLowerCase()] || null;
    }

    has(name) {
        return name.toLowerCase() in this._headers;
    }

    set(name, value) {
        this._headers[name.toLowerCase()] = value;
    }

    append(name, value) {
        var key = name.toLowerCase();
        if (key in this._headers) {
            this._headers[key] += ", " + value;
        } else {
            this._headers[key] = value;
        }
    }

    delete(name) {
        delete this._headers[name.toLowerCase()];
    }

    forEach(callback) {
        for (var key in this._headers) {
            if (this._headers.hasOwnProperty(key)) {
                callback(this._headers[key], key, this);
            }
        }
    }

    keys() {
        return Object.keys(this._headers);
    }

    values() {
        return Object.values(this._headers);
    }

    entries() {
        return Object.entries(this._headers);
    }
}

// MARK: Storage API
/**
 * localStorage implementation using Unity's PlayerPrefs.
 * Matches the web Storage API for compatibility with React and other libraries.
 *
 * @example
 * localStorage.setItem("theme", "dark");
 * const theme = localStorage.getItem("theme"); // "dark"
 * localStorage.removeItem("theme");
 * localStorage.clear();
 *
 * // Also supports index-based access (read-only)
 * const key = localStorage.key(0);
 * const len = localStorage.length;
 */
globalThis.localStorage = {
    /**
     * Returns the value associated with the given key, or null if not found.
     * @param {string} key - The key to look up
     * @returns {string|null} The stored value or null
     */
    getItem: function(key) {
        if (!CS.UnityEngine.PlayerPrefs.HasKey(key)) {
            return null;
        }
        return CS.UnityEngine.PlayerPrefs.GetString(key);
    },

    /**
     * Stores a value with the given key. Overwrites existing values.
     * @param {string} key - The key to store under
     * @param {string} value - The value to store (will be converted to string)
     */
    setItem: function(key, value) {
        CS.UnityEngine.PlayerPrefs.SetString(key, String(value));
        CS.UnityEngine.PlayerPrefs.Save();
    },

    /**
     * Removes the item with the given key.
     * @param {string} key - The key to remove
     */
    removeItem: function(key) {
        CS.UnityEngine.PlayerPrefs.DeleteKey(key);
        CS.UnityEngine.PlayerPrefs.Save();
    },

    /**
     * Removes all items from storage.
     * WARNING: This clears ALL PlayerPrefs, including those set by other systems.
     */
    clear: function() {
        CS.UnityEngine.PlayerPrefs.DeleteAll();
        CS.UnityEngine.PlayerPrefs.Save();
    },

    /**
     * Returns the key at the given index.
     * Note: PlayerPrefs doesn't support enumeration, so this always returns null.
     * @param {number} index - The index of the key
     * @returns {string|null} Always returns null (not supported)
     */
    key: function(index) {
        // PlayerPrefs doesn't support key enumeration
        // This is a limitation compared to web localStorage
        return null;
    },

    /**
     * The number of stored items.
     * Note: PlayerPrefs doesn't support counting, so this always returns 0.
     */
    get length() {
        // PlayerPrefs doesn't support counting keys
        // This is a limitation compared to web localStorage
        return 0;
    }
};

/**
 * sessionStorage implementation (alias to localStorage).
 * In Unity, there's no concept of browser sessions, so sessionStorage
 * behaves identically to localStorage (persists across app restarts).
 *
 * Note: Unlike web sessionStorage, this data persists permanently.
 * Use a prefix like "session_" if you need to manually clear on app start.
 */
globalThis.sessionStorage = globalThis.localStorage;

// MARK: URL API
/**
 * URLSearchParams implementation matching the WHATWG URL Standard.
 * Provides methods for working with query strings.
 *
 * @example
 * const params = new URLSearchParams("foo=1&bar=2");
 * params.get("foo"); // "1"
 * params.append("baz", "3");
 * params.toString(); // "foo=1&bar=2&baz=3"
 */
class URLSearchParams {
    constructor(init) {
        this._params = [];

        if (!init) {
            return;
        }

        if (typeof init === "string") {
            // Remove leading "?" if present
            if (init.startsWith("?")) {
                init = init.slice(1);
            }
            if (init.length > 0) {
                var pairs = init.split("&");
                for (var i = 0; i < pairs.length; i++) {
                    var pair = pairs[i];
                    var eqIdx = pair.indexOf("=");
                    if (eqIdx === -1) {
                        this._params.push([decodeURIComponent(pair), ""]);
                    } else {
                        var key = decodeURIComponent(pair.slice(0, eqIdx).replace(/\+/g, " "));
                        var value = decodeURIComponent(pair.slice(eqIdx + 1).replace(/\+/g, " "));
                        this._params.push([key, value]);
                    }
                }
            }
        } else if (Array.isArray(init)) {
            // Array of [key, value] pairs
            for (var i = 0; i < init.length; i++) {
                this._params.push([String(init[i][0]), String(init[i][1])]);
            }
        } else if (typeof init === "object") {
            // Object with key-value pairs
            for (var key in init) {
                if (init.hasOwnProperty(key)) {
                    this._params.push([key, String(init[key])]);
                }
            }
        }
    }

    append(name, value) {
        this._params.push([String(name), String(value)]);
    }

    delete(name) {
        name = String(name);
        this._params = this._params.filter(function(p) { return p[0] !== name; });
    }

    get(name) {
        name = String(name);
        for (var i = 0; i < this._params.length; i++) {
            if (this._params[i][0] === name) {
                return this._params[i][1];
            }
        }
        return null;
    }

    getAll(name) {
        name = String(name);
        var result = [];
        for (var i = 0; i < this._params.length; i++) {
            if (this._params[i][0] === name) {
                result.push(this._params[i][1]);
            }
        }
        return result;
    }

    has(name) {
        name = String(name);
        for (var i = 0; i < this._params.length; i++) {
            if (this._params[i][0] === name) {
                return true;
            }
        }
        return false;
    }

    set(name, value) {
        name = String(name);
        value = String(value);
        var found = false;
        var newParams = [];
        for (var i = 0; i < this._params.length; i++) {
            if (this._params[i][0] === name) {
                if (!found) {
                    newParams.push([name, value]);
                    found = true;
                }
                // Skip duplicates
            } else {
                newParams.push(this._params[i]);
            }
        }
        if (!found) {
            newParams.push([name, value]);
        }
        this._params = newParams;
    }

    sort() {
        this._params.sort(function(a, b) {
            return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0;
        });
    }

    toString() {
        return this._params.map(function(p) {
            return encodeURIComponent(p[0]) + "=" + encodeURIComponent(p[1]);
        }).join("&");
    }

    keys() {
        return this._params.map(function(p) { return p[0]; });
    }

    values() {
        return this._params.map(function(p) { return p[1]; });
    }

    entries() {
        return this._params.slice();
    }

    forEach(callback, thisArg) {
        for (var i = 0; i < this._params.length; i++) {
            callback.call(thisArg, this._params[i][1], this._params[i][0], this);
        }
    }

    get size() {
        return this._params.length;
    }
}

/**
 * URL implementation matching the WHATWG URL Standard.
 * Parses and manipulates URLs.
 *
 * @example
 * const url = new URL("https://example.com:8080/path?query=1#hash");
 * url.hostname; // "example.com"
 * url.port; // "8080"
 * url.pathname; // "/path"
 * url.searchParams.get("query"); // "1"
 */
class URL {
    constructor(url, base) {
        if (base !== undefined) {
            // Resolve relative URL against base
            var baseUrl = new URL(base);
            url = this._resolveRelative(baseUrl, url);
        }

        this._parse(url);
        this._searchParams = new URLSearchParams(this._search);
    }

    _parse(url) {
        // Default values
        this._protocol = "";
        this._username = "";
        this._password = "";
        this._hostname = "";
        this._port = "";
        this._pathname = "/";
        this._search = "";
        this._hash = "";

        if (!url || typeof url !== "string") {
            throw new TypeError("Invalid URL");
        }

        var remaining = url;

        // Extract hash
        var hashIdx = remaining.indexOf("#");
        if (hashIdx !== -1) {
            this._hash = remaining.slice(hashIdx);
            remaining = remaining.slice(0, hashIdx);
        }

        // Extract search/query
        var searchIdx = remaining.indexOf("?");
        if (searchIdx !== -1) {
            this._search = remaining.slice(searchIdx);
            remaining = remaining.slice(0, searchIdx);
        }

        // Extract protocol
        var protoMatch = remaining.match(/^([a-zA-Z][a-zA-Z0-9+.-]*):\/\//);
        if (protoMatch) {
            this._protocol = protoMatch[1].toLowerCase() + ":";
            remaining = remaining.slice(protoMatch[0].length);
        } else {
            throw new TypeError("Invalid URL: missing protocol");
        }

        // Extract auth (username:password@)
        var authEnd = remaining.indexOf("@");
        if (authEnd !== -1) {
            var auth = remaining.slice(0, authEnd);
            remaining = remaining.slice(authEnd + 1);
            var colonIdx = auth.indexOf(":");
            if (colonIdx !== -1) {
                this._username = decodeURIComponent(auth.slice(0, colonIdx));
                this._password = decodeURIComponent(auth.slice(colonIdx + 1));
            } else {
                this._username = decodeURIComponent(auth);
            }
        }

        // Extract pathname
        var pathIdx = remaining.indexOf("/");
        if (pathIdx !== -1) {
            this._pathname = remaining.slice(pathIdx);
            remaining = remaining.slice(0, pathIdx);
        }

        // Extract port
        var portMatch = remaining.match(/:(\d+)$/);
        if (portMatch) {
            this._port = portMatch[1];
            remaining = remaining.slice(0, -portMatch[0].length);
        }

        // Remaining is hostname
        this._hostname = remaining.toLowerCase();

        if (!this._hostname) {
            throw new TypeError("Invalid URL: missing hostname");
        }
    }

    _resolveRelative(base, relative) {
        if (!relative) {
            return base.href;
        }

        // Absolute URL
        if (/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(relative)) {
            return relative;
        }

        // Protocol-relative
        if (relative.startsWith("//")) {
            return base.protocol + relative;
        }

        // Absolute path
        if (relative.startsWith("/")) {
            return base.origin + relative;
        }

        // Query or hash only
        if (relative.startsWith("?")) {
            return base.origin + base.pathname + relative;
        }
        if (relative.startsWith("#")) {
            return base.origin + base.pathname + base.search + relative;
        }

        // Relative path
        var basePath = base.pathname;
        var lastSlash = basePath.lastIndexOf("/");
        var newPath = basePath.slice(0, lastSlash + 1) + relative;

        return base.origin + newPath;
    }

    get protocol() { return this._protocol; }
    set protocol(value) {
        value = String(value);
        if (!value.endsWith(":")) value += ":";
        this._protocol = value.toLowerCase();
    }

    get username() { return this._username; }
    set username(value) { this._username = String(value); }

    get password() { return this._password; }
    set password(value) { this._password = String(value); }

    get hostname() { return this._hostname; }
    set hostname(value) { this._hostname = String(value).toLowerCase(); }

    get port() { return this._port; }
    set port(value) {
        value = String(value);
        if (value && !/^\d+$/.test(value)) return;
        this._port = value;
    }

    get host() {
        return this._port ? this._hostname + ":" + this._port : this._hostname;
    }
    set host(value) {
        value = String(value);
        var colonIdx = value.lastIndexOf(":");
        if (colonIdx !== -1 && /^\d+$/.test(value.slice(colonIdx + 1))) {
            this._hostname = value.slice(0, colonIdx).toLowerCase();
            this._port = value.slice(colonIdx + 1);
        } else {
            this._hostname = value.toLowerCase();
            this._port = "";
        }
    }

    get pathname() { return this._pathname; }
    set pathname(value) {
        value = String(value);
        if (!value.startsWith("/")) value = "/" + value;
        this._pathname = value;
    }

    get search() { return this._search; }
    set search(value) {
        value = String(value);
        if (value && !value.startsWith("?")) value = "?" + value;
        this._search = value;
        this._searchParams = new URLSearchParams(value);
    }

    get searchParams() {
        return this._searchParams;
    }

    get hash() { return this._hash; }
    set hash(value) {
        value = String(value);
        if (value && !value.startsWith("#")) value = "#" + value;
        this._hash = value;
    }

    get origin() {
        var defaultPorts = { "http:": "80", "https:": "443", "ws:": "80", "wss:": "443" };
        var port = this._port;
        if (port === defaultPorts[this._protocol]) {
            port = "";
        }
        return this._protocol + "//" + (port ? this._hostname + ":" + port : this._hostname);
    }

    get href() {
        var auth = "";
        if (this._username) {
            auth = encodeURIComponent(this._username);
            if (this._password) {
                auth += ":" + encodeURIComponent(this._password);
            }
            auth += "@";
        }

        // Sync search from searchParams
        var search = this._searchParams.toString();
        if (search) search = "?" + search;

        return this._protocol + "//" + auth + this.host + this._pathname + search + this._hash;
    }
    set href(value) {
        this._parse(value);
        this._searchParams = new URLSearchParams(this._search);
    }

    toString() {
        return this.href;
    }

    toJSON() {
        return this.href;
    }
}

// Expose globally
globalThis.URL = URL;
globalThis.URLSearchParams = URLSearchParams;