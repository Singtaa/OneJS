using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace OneJS.Editor.TypeGenerator {
    /// <summary>
    /// Generates TypeScript declaration files from analyzed type info
    /// </summary>
    public class TypeScriptEmitter {
        private readonly StringBuilder _sb;
        private int _indent;
        private readonly EmitterOptions _options;
        private bool _atLineStart = true;

        public TypeScriptEmitter(EmitterOptions options = null) {
            _sb = new StringBuilder();
            _options = options ?? new EmitterOptions();
        }

        /// <summary>
        /// Generates a complete .d.ts file from a collection of types
        /// </summary>
        public string Emit(IEnumerable<TsTypeInfo> types) {
            _sb.Clear();
            _indent = 0;
            _atLineStart = true;

            if (!_options.SkipHeader) {
                EmitHeader();
                EmitHelperTypes();
            }

            // Group types by namespace
            var namespaces = types
                .GroupBy(t => t.Namespace ?? "")
                .OrderBy(g => g.Key);

            AppendLine("declare namespace CS {");
            _indent++;

            // Emit keep_incompatibility symbol if we're emitting the marker in classes
            if (_options.EmitIncompatibilityMarker) {
                AppendLine("const __keep_incompatibility: symbol;");
                AppendLine();
            }

            foreach (var ns in namespaces) {
                EmitNamespace(ns.Key, ns.ToList());
            }

            _indent--;
            AppendLine("}");

            // Export module declaration if needed
            if (_options.EmitModuleDeclaration) {
                AppendLine();
                AppendLine("declare module 'csharp' {");
                _indent++;
                AppendLine("export = CS;");
                _indent--;
                AppendLine("}");
            }

            return _sb.ToString();
        }

        private void EmitHeader() {
            AppendLine("// Generated by OneJS Type Generator");
            AppendLine($"// Date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            AppendLine();
        }

        private void EmitHelperTypes() {
            AppendLine("// Helper types for C# interop");
            AppendLine("declare interface $Ref<T> {");
            _indent++;
            AppendLine("__doNotAccess: T;");
            _indent--;
            AppendLine("}");
            AppendLine();

            AppendLine("declare interface $Out<T> {");
            _indent++;
            AppendLine("__doNotAccess: T;");
            _indent--;
            AppendLine("}");
            AppendLine();

            AppendLine("declare interface $Task<T> {");
            _indent++;
            AppendLine("__doNotAccess: T;");
            _indent--;
            AppendLine("}");
            AppendLine();
        }

        private void EmitNamespace(string namespaceName, List<TsTypeInfo> types) {
            if (!string.IsNullOrEmpty(namespaceName)) {
                // Split nested namespaces
                var parts = namespaceName.Split('.');
                foreach (var part in parts) {
                    AppendLine($"namespace {part} {{");
                    _indent++;
                }
            }

            foreach (var type in types) {
                EmitType(type);
                AppendLine();
            }

            if (!string.IsNullOrEmpty(namespaceName)) {
                var parts = namespaceName.Split('.');
                for (int i = 0; i < parts.Length; i++) {
                    _indent--;
                    AppendLine("}");
                }
            }
        }

        private void EmitType(TsTypeInfo type) {
            // Emit documentation
            if (!string.IsNullOrEmpty(type.Documentation) && _options.IncludeDocumentation) {
                EmitDocumentation(type.Documentation);
            }

            // Emit obsolete warning
            if (type.IsObsolete && _options.IncludeObsoleteWarnings) {
                AppendLine($"/** @deprecated {type.ObsoleteMessage ?? ""} */");
            }

            switch (type.Kind) {
                case TsTypeKind.Enum:
                    EmitEnum(type);
                    break;
                case TsTypeKind.Delegate:
                    EmitDelegate(type);
                    break;
                case TsTypeKind.Interface:
                    EmitInterface(type);
                    break;
                default:
                    EmitClass(type);
                    break;
            }

            // Emit extension methods as interface augmentation
            if (type.ExtensionMethods?.Count > 0) {
                EmitExtensionMethods(type);
            }
        }

        private void EmitEnum(TsTypeInfo type) {
            AppendLine($"enum {type.Name} {{");
            _indent++;

            for (int i = 0; i < type.EnumMembers.Count; i++) {
                var member = type.EnumMembers[i];
                var suffix = i < type.EnumMembers.Count - 1 ? "," : "";
                AppendLine($"{member.Name} = {member.Value}{suffix}");
            }

            _indent--;
            AppendLine("}");
        }

        private void EmitDelegate(TsTypeInfo type) {
            // Emit as interface with call signature
            Append($"interface {type.Name}");

            if (type.IsGenericTypeDefinition) {
                EmitGenericParameters(type.GenericParameters, type.GenericConstraints);
            }

            AppendLine(" {");
            _indent++;

            if (type.DelegateSignature != null) {
                var sig = type.DelegateSignature;
                var paramList = string.Join(", ", sig.Parameters.Select(p => p.ToTypeScript()));
                var returnType = sig.ReturnType?.ToTypeScript() ?? "void";

                AppendLine($"({paramList}): {returnType};");
                AppendLine($"Invoke?: ({paramList}) => {returnType};");
            }

            _indent--;
            AppendLine("}");

            // Emit constructor for non-generic delegates
            if (!type.IsGenericTypeDefinition && type.DelegateSignature != null) {
                var sig = type.DelegateSignature;
                var paramList = string.Join(", ", sig.Parameters.Select(p => p.ToTypeScript()));
                var returnType = sig.ReturnType?.ToTypeScript() ?? "void";

                AppendLine($"var {type.Name}: {{ new (func: ({paramList}) => {returnType}): {type.Name}; }};");
            }
        }

        private void EmitInterface(TsTypeInfo type) {
            Append($"interface {type.Name}");

            if (type.IsGenericTypeDefinition) {
                EmitGenericParameters(type.GenericParameters, type.GenericConstraints);
            }

            // Extends clause
            var extends = new List<string>();
            if (type.Interfaces.Count > 0) {
                extends.AddRange(type.Interfaces.Select(i => i.ToTypeScript()));
            }

            if (extends.Count > 0) {
                Append($" extends {string.Join(", ", extends)}");
            }

            AppendLine(" {");
            _indent++;

            EmitMembers(type, isInterface: true);

            _indent--;
            AppendLine("}");

            // Emit nested types in a companion namespace (TypeScript doesn't support nested types in interfaces)
            if (type.NestedTypes?.Count > 0) {
                AppendLine($"namespace {type.Name} {{");
                _indent++;

                foreach (var nested in type.NestedTypes) {
                    EmitType(nested);
                    AppendLine();
                }

                _indent--;
                AppendLine("}");
            }
        }

        private void EmitClass(TsTypeInfo type) {
            Append($"class {type.Name}");

            if (type.IsGenericTypeDefinition) {
                EmitGenericParameters(type.GenericParameters, type.GenericConstraints);
            }

            // Extends clause
            if (type.BaseType != null) {
                Append($" extends {type.BaseType.ToTypeScript()}");
            }

            // Implements clause
            if (type.Interfaces.Count > 0) {
                Append($" implements {string.Join(", ", type.Interfaces.Select(i => i.ToTypeScript()))}");
            }

            AppendLine(" {");
            _indent++;

            // Emit incompatibility marker for proper type checking
            if (_options.EmitIncompatibilityMarker) {
                AppendLine("protected [__keep_incompatibility]: never;");
            }

            EmitMembers(type, isInterface: false);

            _indent--;
            AppendLine("}");

            // Emit nested types in a companion namespace (TypeScript doesn't support nested classes)
            if (type.NestedTypes?.Count > 0) {
                AppendLine($"namespace {type.Name} {{");
                _indent++;

                foreach (var nested in type.NestedTypes) {
                    EmitType(nested);
                    AppendLine();
                }

                _indent--;
                AppendLine("}");
            }
        }

        private void EmitMembers(TsTypeInfo type, bool isInterface) {
            // Fields
            foreach (var field in type.Fields) {
                EmitField(field, isInterface);
            }

            // Properties
            foreach (var prop in type.Properties) {
                EmitProperty(prop, isInterface);
            }

            // Constructors (only for classes)
            if (!isInterface) {
                foreach (var ctor in type.Constructors) {
                    EmitConstructor(ctor);
                }
            }

            // Methods
            foreach (var method in type.Methods) {
                EmitMethod(method, isInterface);
            }

            // Events
            foreach (var evt in type.Events) {
                EmitEvent(evt, isInterface);
            }

            // Indexers
            foreach (var indexer in type.Indexers) {
                EmitIndexer(indexer, isInterface);
            }
        }

        private void EmitField(TsFieldInfo field, bool isInterface) {
            if (_options.IncludeDocumentation && !string.IsNullOrEmpty(field.Documentation)) {
                EmitDocumentation(field.Documentation);
            }

            if (!isInterface) Append("public ");
            if (field.IsStatic) Append("static ");
            if (field.IsReadOnly || field.IsConst) Append("readonly ");

            AppendLine($"{field.Name}: {field.Type.ToTypeScript()};");
        }

        private void EmitProperty(TsPropertyInfo prop, bool isInterface) {
            if (_options.IncludeDocumentation && !string.IsNullOrEmpty(prop.Documentation)) {
                EmitDocumentation(prop.Documentation);
            }

            var typeName = prop.Type.ToTypeScript();

            // Use get/set accessors for read-only or write-only properties
            if (_options.UseAccessorSyntax && (prop.HasGetter != prop.HasSetter)) {
                if (prop.HasGetter) {
                    if (!isInterface) Append("public ");
                    if (prop.IsStatic) Append("static ");
                    AppendLine($"get {prop.Name}(): {typeName};");
                }
                if (prop.HasSetter) {
                    if (!isInterface) Append("public ");
                    if (prop.IsStatic) Append("static ");
                    AppendLine($"set {prop.Name}(value: {typeName});");
                }
            } else {
                // Simple property syntax
                if (!isInterface) Append("public ");
                if (prop.IsStatic) Append("static ");
                AppendLine($"{prop.Name}: {typeName};");
            }
        }

        private void EmitConstructor(TsMethodInfo ctor) {
            if (_options.IncludeDocumentation && !string.IsNullOrEmpty(ctor.Documentation)) {
                EmitDocumentation(ctor.Documentation);
            }

            var paramList = string.Join(", ", ctor.Parameters.Select(p => p.ToTypeScript()));
            AppendLine($"constructor({paramList});");
        }

        private void EmitMethod(TsMethodInfo method, bool isInterface) {
            if (_options.IncludeDocumentation && !string.IsNullOrEmpty(method.Documentation)) {
                EmitDocumentation(method.Documentation);
            }

            if (method.IsObsolete && _options.IncludeObsoleteWarnings) {
                AppendLine($"/** @deprecated {method.ObsoleteMessage ?? ""} */");
            }

            if (!isInterface) Append("public ");
            if (method.IsStatic) Append("static ");

            Append(method.Name);

            // Generic parameters
            if (method.IsGenericMethod) {
                EmitGenericParameters(method.GenericParameters, method.GenericConstraints);
            }

            // Parameters
            var paramList = string.Join(", ", method.Parameters.Select(p => p.ToTypeScript()));
            Append($"({paramList})");

            // Return type
            var returnType = method.ReturnType?.ToTypeScript() ?? "void";
            AppendLine($": {returnType};");
        }

        private void EmitEvent(TsEventInfo evt, bool isInterface) {
            var handlerType = evt.EventHandlerType?.ToTypeScript() ?? "Function";

            // add_EventName
            if (!isInterface) Append("public ");
            if (evt.IsStatic) Append("static ");
            AppendLine($"add_{evt.Name}(handler: {handlerType}): void;");

            // remove_EventName
            if (!isInterface) Append("public ");
            if (evt.IsStatic) Append("static ");
            AppendLine($"remove_{evt.Name}(handler: {handlerType}): void;");
        }

        private void EmitIndexer(TsIndexerInfo indexer, bool isInterface) {
            var paramList = string.Join(", ", indexer.Parameters.Select(p => p.ToTypeScript()));
            var returnType = indexer.ReturnType?.ToTypeScript() ?? "any";

            if (indexer.HasGetter) {
                if (!isInterface) Append("public ");
                AppendLine($"get_Item({paramList}): {returnType};");
            }

            if (indexer.HasSetter) {
                if (!isInterface) Append("public ");
                AppendLine($"set_Item({paramList}, value: {returnType}): void;");
            }
        }

        private void EmitExtensionMethods(TsTypeInfo type) {
            AppendLine();
            Append($"interface {type.Name}");

            if (type.IsGenericTypeDefinition) {
                EmitGenericParameters(type.GenericParameters, null);
            }

            AppendLine(" {");
            _indent++;

            foreach (var method in type.ExtensionMethods) {
                EmitMethod(method, isInterface: true);
            }

            _indent--;
            AppendLine("}");
        }

        private void EmitGenericParameters(List<string> parameters, List<TsGenericConstraint> constraints) {
            if (parameters == null || parameters.Count == 0) return;

            Append("<");
            for (int i = 0; i < parameters.Count; i++) {
                if (i > 0) Append(", ");
                Append(parameters[i]);

                // Add constraint
                var constraint = constraints?.FirstOrDefault(c => c.ParameterName == parameters[i]);
                if (constraint != null && constraint.HasConstraints) {
                    var constraintStr = constraint.ToTypeScript();
                    if (!string.IsNullOrEmpty(constraintStr)) {
                        Append($" extends {constraintStr}");
                    }
                }
            }
            Append(">");
        }

        private void EmitDocumentation(string doc) {
            if (string.IsNullOrEmpty(doc)) return;

            var lines = doc.Split(new[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries);
            if (lines.Length == 1) {
                AppendLine($"/** {lines[0].Trim()} */");
            } else {
                AppendLine("/**");
                foreach (var line in lines) {
                    AppendLine($" * {line.Trim()}");
                }
                AppendLine(" */");
            }
        }

        private void Append(string text) {
            if (_atLineStart && !string.IsNullOrEmpty(text)) {
                _sb.Append(new string(' ', _indent * 4));
                _atLineStart = false;
            }
            _sb.Append(text);
        }

        private void AppendLine(string text = "") {
            if (string.IsNullOrEmpty(text)) {
                _sb.AppendLine();
            } else {
                if (_atLineStart) {
                    _sb.Append(new string(' ', _indent * 4));
                }
                _sb.AppendLine(text);
            }
            _atLineStart = true;
        }
    }

    /// <summary>
    /// Options for TypeScript emission
    /// </summary>
    public class EmitterOptions {
        public bool IncludeDocumentation { get; set; } = true;
        public bool IncludeObsoleteWarnings { get; set; } = true;
        public bool EmitModuleDeclaration { get; set; } = false;
        public bool EmitIncompatibilityMarker { get; set; } = true;
        public bool UseAccessorSyntax { get; set; } = true;

        /// <summary>
        /// When true, skips emitting the header comment, helper types ($Ref, $Out, $Task),
        /// and __keep_incompatibility symbol. Use for files that will be combined into a package.
        /// </summary>
        public bool SkipHeader { get; set; } = false;
    }
}
